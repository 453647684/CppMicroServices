---
layout: default
title: Module Class Reference
---
  <head>
    <title>C++ Micro Services: Module Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
  </head>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classModule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Module Class Reference<div class="ingroups"><a class="el" href="group__MicroServices.html">Micro Services Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a CppMicroServices module.  
 <a href="classModule.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c9d9c096786d127590fdd8aa2b7d681"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a7c9d9c096786d127590fdd8aa2b7d681">~Module</a> ()</td></tr>
<tr class="separator:a7c9d9c096786d127590fdd8aa2b7d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb822aabcaa58664e4802d736542d9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a6eb822aabcaa58664e4802d736542d9b">IsLoaded</a> () const </td></tr>
<tr class="memdesc:a6eb822aabcaa58664e4802d736542d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's current state.  <a href="#a6eb822aabcaa58664e4802d736542d9b">More...</a><br/></td></tr>
<tr class="separator:a6eb822aabcaa58664e4802d736542d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c027deb575198ba11a37cca2f2faf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModuleContext.html">ModuleContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a66c027deb575198ba11a37cca2f2faf7">GetModuleContext</a> () const </td></tr>
<tr class="memdesc:a66c027deb575198ba11a37cca2f2faf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's <a class="el" href="classModuleContext.html">ModuleContext</a>.  <a href="#a66c027deb575198ba11a37cca2f2faf7">More...</a><br/></td></tr>
<tr class="separator:a66c027deb575198ba11a37cca2f2faf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179725f9aecd04cf59f0a8e74cdf05a4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a179725f9aecd04cf59f0a8e74cdf05a4">GetModuleId</a> () const </td></tr>
<tr class="memdesc:a179725f9aecd04cf59f0a8e74cdf05a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's unique identifier.  <a href="#a179725f9aecd04cf59f0a8e74cdf05a4">More...</a><br/></td></tr>
<tr class="separator:a179725f9aecd04cf59f0a8e74cdf05a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597849fb68ab647e26f887a9a5030790"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a597849fb68ab647e26f887a9a5030790">GetLocation</a> () const </td></tr>
<tr class="memdesc:a597849fb68ab647e26f887a9a5030790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's location.  <a href="#a597849fb68ab647e26f887a9a5030790">More...</a><br/></td></tr>
<tr class="separator:a597849fb68ab647e26f887a9a5030790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71880e4be55811df7aeab43a5c9046b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a71880e4be55811df7aeab43a5c9046b4">GetName</a> () const </td></tr>
<tr class="memdesc:a71880e4be55811df7aeab43a5c9046b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this module as specified by the US_CREATE_MODULE CMake macro.  <a href="#a71880e4be55811df7aeab43a5c9046b4">More...</a><br/></td></tr>
<tr class="separator:a71880e4be55811df7aeab43a5c9046b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c96bbe3653bec5a8ed5d1b56d6cddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModuleVersion.html">ModuleVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a20c96bbe3653bec5a8ed5d1b56d6cddf">GetVersion</a> () const </td></tr>
<tr class="memdesc:a20c96bbe3653bec5a8ed5d1b56d6cddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version of this module as specified by the US_INITIALIZE_MODULE CMake macro.  <a href="#a20c96bbe3653bec5a8ed5d1b56d6cddf">More...</a><br/></td></tr>
<tr class="separator:a20c96bbe3653bec5a8ed5d1b56d6cddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa885cfb92466c142e1903bb6fab638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAny.html">Any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a3fa885cfb92466c142e1903bb6fab638">GetProperty</a> (const std::string &amp;key) const </td></tr>
<tr class="memdesc:a3fa885cfb92466c142e1903bb6fab638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the specified property for this module.  <a href="#a3fa885cfb92466c142e1903bb6fab638">More...</a><br/></td></tr>
<tr class="separator:a3fa885cfb92466c142e1903bb6fab638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0417ce52b2b1dedfe513a66cb3cb432c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a0417ce52b2b1dedfe513a66cb3cb432c">GetPropertyKeys</a> () const </td></tr>
<tr class="memdesc:a0417ce52b2b1dedfe513a66cb3cb432c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of top-level property keys for this module.  <a href="#a0417ce52b2b1dedfe513a66cb3cb432c">More...</a><br/></td></tr>
<tr class="separator:a0417ce52b2b1dedfe513a66cb3cb432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab1e28d22d60b049c515d4256363b44"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classServiceReference.html">ServiceReferenceU</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a8ab1e28d22d60b049c515d4256363b44">GetRegisteredServices</a> () const </td></tr>
<tr class="memdesc:a8ab1e28d22d60b049c515d4256363b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it has registered or an empty list if this module has no registered services.  <a href="#a8ab1e28d22d60b049c515d4256363b44">More...</a><br/></td></tr>
<tr class="separator:a8ab1e28d22d60b049c515d4256363b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6934e75db2be837723fb6e21125bca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classServiceReference.html">ServiceReferenceU</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#adf6934e75db2be837723fb6e21125bca">GetServicesInUse</a> () const </td></tr>
<tr class="memdesc:adf6934e75db2be837723fb6e21125bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it is using or returns an empty list if this module is not using any services.  <a href="#adf6934e75db2be837723fb6e21125bca">More...</a><br/></td></tr>
<tr class="separator:adf6934e75db2be837723fb6e21125bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663b9033cb569becb414ca4d9064622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModuleResource.html">ModuleResource</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ae663b9033cb569becb414ca4d9064622">GetResource</a> (const std::string &amp;path) const </td></tr>
<tr class="memdesc:ae663b9033cb569becb414ca4d9064622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resource at the specified <code>path</code> in this module.  <a href="#ae663b9033cb569becb414ca4d9064622">More...</a><br/></td></tr>
<tr class="separator:ae663b9033cb569becb414ca4d9064622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9766f0366ddd2ac0b838f17d1e262e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classModuleResource.html">ModuleResource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a1b9766f0366ddd2ac0b838f17d1e262e">FindResources</a> (const std::string &amp;path, const std::string &amp;filePattern, bool recurse) const </td></tr>
<tr class="memdesc:a1b9766f0366ddd2ac0b838f17d1e262e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resources in this module and its statically linked modules.  <a href="#a1b9766f0366ddd2ac0b838f17d1e262e">More...</a><br/></td></tr>
<tr class="separator:a1b9766f0366ddd2ac0b838f17d1e262e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad6bd8ff9e1efe6f883d939481a030fbc"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ad6bd8ff9e1efe6f883d939481a030fbc">PROP_ID</a> ()</td></tr>
<tr class="memdesc:ad6bd8ff9e1efe6f883d939481a030fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key for looking up this module's id.  <a href="#ad6bd8ff9e1efe6f883d939481a030fbc">More...</a><br/></td></tr>
<tr class="separator:ad6bd8ff9e1efe6f883d939481a030fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab605045d336e05ee0c8a7925fbe3234b"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ab605045d336e05ee0c8a7925fbe3234b">PROP_NAME</a> ()</td></tr>
<tr class="memdesc:ab605045d336e05ee0c8a7925fbe3234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key for looking up this module's name.  <a href="#ab605045d336e05ee0c8a7925fbe3234b">More...</a><br/></td></tr>
<tr class="separator:ab605045d336e05ee0c8a7925fbe3234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e41a7671443f5e0ff345950b9949b81"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a0e41a7671443f5e0ff345950b9949b81">PROP_LOCATION</a> ()</td></tr>
<tr class="memdesc:a0e41a7671443f5e0ff345950b9949b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key for looking up this module's location the file system.  <a href="#a0e41a7671443f5e0ff345950b9949b81">More...</a><br/></td></tr>
<tr class="separator:a0e41a7671443f5e0ff345950b9949b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad616f286d832d168958541f316e2a81"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#aad616f286d832d168958541f316e2a81">PROP_VERSION</a> ()</td></tr>
<tr class="memdesc:aad616f286d832d168958541f316e2a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.version</code> for looking up this module's version identifier.  <a href="#aad616f286d832d168958541f316e2a81">More...</a><br/></td></tr>
<tr class="separator:aad616f286d832d168958541f316e2a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf1aac88e946fff1ae72895698496ce"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#abdf1aac88e946fff1ae72895698496ce">PROP_VENDOR</a> ()</td></tr>
<tr class="memdesc:abdf1aac88e946fff1ae72895698496ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.vendor</code> for looking up this module's vendor information.  <a href="#abdf1aac88e946fff1ae72895698496ce">More...</a><br/></td></tr>
<tr class="separator:abdf1aac88e946fff1ae72895698496ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036bca9543c13741b0eee9656550041c"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a036bca9543c13741b0eee9656550041c">PROP_DESCRIPTION</a> ()</td></tr>
<tr class="memdesc:a036bca9543c13741b0eee9656550041c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.description</code> for looking up this module's description.  <a href="#a036bca9543c13741b0eee9656550041c">More...</a><br/></td></tr>
<tr class="separator:a036bca9543c13741b0eee9656550041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9986bc0261acc8b4a8321c561215a69"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ae9986bc0261acc8b4a8321c561215a69">PROP_AUTOLOAD_DIR</a> ()</td></tr>
<tr class="memdesc:ae9986bc0261acc8b4a8321c561215a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.autoload_dir</code> for looking up this module's auto-load directory.  <a href="#ae9986bc0261acc8b4a8321c561215a69">More...</a><br/></td></tr>
<tr class="separator:ae9986bc0261acc8b4a8321c561215a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a CppMicroServices module. </p>
<p>A <code>Module</code> object is the access point to a CppMicroServices module. Each CppMicroServices module has an associated <code>Module</code> object.</p>
<p>A module has unique identity, a <code>long</code>, chosen by the framework. This identity does not change during the lifecycle of a module.</p>
<p>A module can be in one of two states: </p>
<ul>
<li>
LOADED </li>
<li>
UNLOADED </li>
</ul>
<p>You can determine the current state by using <a class="el" href="classModule.html#a6eb822aabcaa58664e4802d736542d9b" title="Returns this module&#39;s current state. ">IsLoaded()</a>.</p>
<p>A module can only execute code when its state is <code>LOADED</code>. An <code>UNLOADED</code> module is a zombie and can only be reached because it was loaded before. However, unloaded modules can be loaded again.</p>
<p>The framework is the only entity that is allowed to create <code>Module</code> objects.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This class is thread safe. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c9d9c096786d127590fdd8aa2b7d681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Module::~Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b9766f0366ddd2ac0b838f17d1e262e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classModuleResource.html">ModuleResource</a>&gt; Module::FindResources </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns resources in this module and its statically linked modules. </p>
<p>This method is intended to be used to obtain configuration, setup, localization and other information from this module.</p>
<p>This method can either return only resources in the specified <code>path</code> or recurse into subdirectories returning resources in the directory tree beginning at the specified path.</p>
<p>Examples: </p>
<div class="fragment"><div class="line">  <a class="code" href="classModuleContext.html">ModuleContext</a>* moduleContext = <a class="code" href="classModule.html#a66c027deb575198ba11a37cca2f2faf7">GetModuleContext</a>();</div>
<div class="line">  <a class="code" href="classModule.html">Module</a>* module = moduleContext-&gt;<a class="code" href="classModuleContext.html#ae4fc39476ca5a30e0cbe5af26de4b4e3">GetModule</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// List all XML files in the config directory</span></div>
<div class="line">  std::vector&lt;ModuleResource&gt; xmlFiles = module-&gt;<a class="code" href="classModule.html#a1b9766f0366ddd2ac0b838f17d1e262e">FindResources</a>(<span class="stringliteral">&quot;config&quot;</span>, <span class="stringliteral">&quot;*.xml&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Find the resource named vertex_shader.txt starting at the root directory</span></div>
<div class="line">  std::vector&lt;ModuleResource&gt; shaders = module-&gt;<a class="code" href="classModule.html#a1b9766f0366ddd2ac0b838f17d1e262e">FindResources</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;vertex_shader.txt&quot;</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In case of modules statically linked into this module, the returned <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> objects can represent the same resource path, coming from different static modules. The order of the <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> objects in the returned container matches the order of the static module names in the <a class="el" href="group__MicroServices.html#gaa01807d90beef417c9107c97b19c3bde" title="Import a list of static modules into a shared library. ">US_LOAD_IMPORTED_MODULES</a> macro.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path name in which to look. The path is always relative to the root of this module and may begin with '/'. A path value of "/" indicates the root of this module. </td></tr>
    <tr><td class="paramname">filePattern</td><td>The resource name pattern for selecting entries in the specified path. The pattern is only matched against the last element of the resource path. Substring matching is supported using the wildcard charachter ('*'). If <code>filePattern</code> is empty, this is equivalent to "*" and matches all resources. </td></tr>
    <tr><td class="paramname">recurse</td><td>If <code>true</code>, recurse into subdirectories. Otherwise only return resources from the specified path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> objects for each matching entry. The objects are sorted such that resources from this module are returned first followed by the resources from statically linked modules in the load order as specified in <a class="el" href="group__MicroServices.html#gaa01807d90beef417c9107c97b19c3bde" title="Import a list of static modules into a shared library. ">US_LOAD_IMPORTED_MODULES</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a597849fb68ab647e26f887a9a5030790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Module::GetLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's location. </p>
<p>The location is the full path to the module's shared library. This method continues to return this module's location while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The string representation of this module's location. </dd></dl>

</div>
</div>
<a class="anchor" id="a66c027deb575198ba11a37cca2f2faf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModuleContext.html">ModuleContext</a>* Module::GetModuleContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's <a class="el" href="classModuleContext.html">ModuleContext</a>. </p>
<p>The returned <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code> can be used by the caller to act on behalf of this module.</p>
<p>If this module is not in the <code>LOADED</code> state, then this module has no valid <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code>. This method will return <code>0</code> if this module has no valid <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code> for this module or <code>0</code> if this module has no valid <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a179725f9aecd04cf59f0a8e74cdf05a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Module::GetModuleId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's unique identifier. </p>
<p>This module is assigned a unique identifier by the framework when it was loaded.</p>
<p>A module's unique identifier has the following attributes: </p>
<ul>
<li>
Is unique. </li>
<li>
Is a <code>long</code>. </li>
<li>
Its value is not reused for another module, even after a module is unloaded. </li>
<li>
Does not change while a module remains loaded. </li>
<li>
Does not change when a module is reloaded. </li>
</ul>
<p>This method continues to return this module's unique identifier while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The unique identifier of this module. </dd></dl>

</div>
</div>
<a class="anchor" id="a71880e4be55811df7aeab43a5c9046b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Module::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of this module as specified by the US_CREATE_MODULE CMake macro. </p>
<p>The module name together with a version must identify a unique module.</p>
<p>This method continues to return this module's name while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of this module. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fa885cfb92466c142e1903bb6fab638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAny.html">Any</a> Module::GetProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the specified property for this module. </p>
<p>The method returns an empty <a class="el" href="classAny.html" title="An Any class represents a general type and is capable of storing any type, supporting type-safe extra...">Any</a> if the property is not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the requested property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the requested property, or an empty string if the property is undefined.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModule.html#a0417ce52b2b1dedfe513a66cb3cb432c" title="Returns a list of top-level property keys for this module. ">GetPropertyKeys()</a> </dd>
<dd>
<a class="el" href="MicroServices_ModuleProperties.html">Module Properties</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0417ce52b2b1dedfe513a66cb3cb432c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Module::GetPropertyKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of top-level property keys for this module. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of available property keys.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="MicroServices_ModuleProperties.html">Module Properties</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab1e28d22d60b049c515d4256363b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classServiceReference.html">ServiceReferenceU</a>&gt; Module::GetRegisteredServices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it has registered or an empty list if this module has no registered services. </p>
<p>The list is valid at the time of the call to this method, however, as the framework is a very dynamic environment, services can be modified or unregistered at anytime.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> objects for services this module has registered. </dd></dl>

</div>
</div>
<a class="anchor" id="ae663b9033cb569becb414ca4d9064622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModuleResource.html">ModuleResource</a> Module::GetResource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the resource at the specified <code>path</code> in this module. </p>
<p>The specified <code>path</code> is always relative to the root of this module and may begin with '/'. A path value of "/" indicates the root of this module.</p>
<dl class="section note"><dt>Note</dt><dd>In case of other modules being statically linked into this module, the <code>path</code> can be ambiguous and returns the first resource matching the provided <code>path</code> according to the order of the static module names in the <a class="el" href="group__MicroServices.html#gaa01807d90beef417c9107c97b19c3bde" title="Import a list of static modules into a shared library. ">US_LOAD_IMPORTED_MODULES</a> macro.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path name of the resource. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> object for the given <code>path</code>. If the <code>path</code> cannot be found in this module or the module's state is <code>UNLOADED</code>, an invalid <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> object is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="adf6934e75db2be837723fb6e21125bca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classServiceReference.html">ServiceReferenceU</a>&gt; Module::GetServicesInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it is using or returns an empty list if this module is not using any services. </p>
<p>A module is considered to be using a service if its use count for that service is greater than zero.</p>
<p>The list is valid at the time of the call to this method, however, as the framework is a very dynamic environment, services can be modified or unregistered at anytime.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> objects for all services this module is using. </dd></dl>

</div>
</div>
<a class="anchor" id="a20c96bbe3653bec5a8ed5d1b56d6cddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModuleVersion.html">ModuleVersion</a> Module::GetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the version of this module as specified by the US_INITIALIZE_MODULE CMake macro. </p>
<p>If this module does not have a specified version then <a class="el" href="classModuleVersion.html#a75ea56c0729937b39345301674b434a2">ModuleVersion::EmptyVersion</a> is returned.</p>
<p>This method continues to return this module's version while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The version of this module. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb822aabcaa58664e4802d736542d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Module::IsLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's current state. </p>
<p>A module can be in only one state at any time.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the module is <code>LOADED</code> <code>false</code> if it is <code>UNLOADED</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae9986bc0261acc8b4a8321c561215a69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_AUTOLOAD_DIR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.autoload_dir</code> for looking up this module's auto-load directory. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The version property key. </dd></dl>

</div>
</div>
<a class="anchor" id="a036bca9543c13741b0eee9656550041c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_DESCRIPTION </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.description</code> for looking up this module's description. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The version property key. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6bd8ff9e1efe6f883d939481a030fbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_ID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key for looking up this module's id. </p>
<p>The property value is of type <code>long</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The id property key. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e41a7671443f5e0ff345950b9949b81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_LOCATION </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key for looking up this module's location the file system. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The location property key. </dd></dl>

</div>
</div>
<a class="anchor" id="ab605045d336e05ee0c8a7925fbe3234b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_NAME </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key for looking up this module's name. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The name property key. </dd></dl>

</div>
</div>
<a class="anchor" id="abdf1aac88e946fff1ae72895698496ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_VENDOR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.vendor</code> for looking up this module's vendor information. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The version property key. </dd></dl>

</div>
</div>
<a class="anchor" id="aad616f286d832d168958541f316e2a81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_VERSION </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.version</code> for looking up this module's version identifier. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The version property key. </dd></dl>

</div>
</div>
</div><!-- contents -->

  <hr class="footer"/>
  <address class="footer"><small>Generated on Mon Dec 23 2013 for C++ Micro Services 2.0.0 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.5
</small></address>
