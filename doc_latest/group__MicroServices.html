---
layout: default
title: Micro Services Classes
---
  <head>
    <title>C++ Micro Services: Micro Services Classes</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
  </head>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Micro Services Classes</div>  </div>
</div><!--header-->
<div class="contents">

<p>This category includes classes related to the C++ Micro Services component.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceServiceConstants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceServiceConstants.html">ServiceConstants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFramework.html">Framework</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CppMicroServices <a class="el" href="classFramework.html" title="The CppMicroServices Framework. ">Framework</a>.  <a href="classFramework.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFrameworkFactory.html">FrameworkFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory for creating <a class="el" href="classFramework.html" title="The CppMicroServices Framework. ">Framework</a> instances.  <a href="classFrameworkFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLDAPFilter.html">LDAPFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a href="http://www.ietf.org/rfc/rfc1960.txt">RFC 1960</a>-based Filter.  <a href="classLDAPFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html">Module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a CppMicroServices module.  <a href="classModule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structModuleActivator.html">ModuleActivator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customizes the starting and stopping of a CppMicroServices module.  <a href="structModuleActivator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html">ModuleContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module's execution context within the framework.  <a href="classModuleContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleEvent.html">ModuleEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event from the Micro Services framework describing a module lifecycle change.  <a href="classModuleEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structModuleEventHook.html">ModuleEventHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module Event Hook Service.  <a href="structModuleEventHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structModuleFindHook.html">ModuleFindHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module Context Hook Service.  <a href="structModuleFindHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleResource.html">ModuleResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a resource (text file, image, etc.) embedded in a CppMicroServices module.  <a href="classModuleResource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleResourceStream.html">ModuleResourceStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input stream class for <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> objects.  <a href="classModuleResourceStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleSettings.html">ModuleSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query and set certain properties of the CppMicroServices library.  <a href="classModuleSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleVersion.html">ModuleVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version identifier for CppMicroServices modules.  <a href="classModuleVersion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPrototypeServiceFactory.html">PrototypeServiceFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory for <a class="el" href="namespaceServiceConstants.html#a2c8d31ab79a0729525b6f0bf0678de4b">prototype scope</a> services.  <a href="structPrototypeServiceFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceEvent.html">ServiceEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event from the Micro Services framework describing a service lifecycle change.  <a href="classServiceEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structServiceEventListenerHook.html">ServiceEventListenerHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service Event Listener Hook Service.  <a href="structServiceEventListenerHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceException.html">ServiceException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A service exception used to indicate that a service problem occurred.  <a href="classServiceException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceFactory.html">ServiceFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory for <a class="el" href="namespaceServiceConstants.html#ab298987fa3571d170e8a6bc527993818">module scope</a> services.  <a href="classServiceFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structServiceFindHook.html">ServiceFindHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service Find Hook Service.  <a href="structServiceFindHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMakeInterfaceMap.html">MakeInterfaceMap&lt; Interfaces &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for constructing InterfaceMap instances based on service implementations or service factories.  <a href="structMakeInterfaceMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structServiceListenerHook.html">ServiceListenerHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service Listener Hook Service.  <a href="structServiceListenerHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structServiceListenerHook_1_1ListenerInfo.html">ServiceListenerHook::ListenerInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a Service Listener.  <a href="structServiceListenerHook_1_1ListenerInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceObjects.html">ServiceObjects&lt; S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows multiple service objects for a service to be obtained.  <a href="classServiceObjects.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceObjects_3_01void_01_4.html">ServiceObjects&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows multiple service objects for a service to be obtained.  <a href="classServiceObjects_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceReference.html">ServiceReference&lt; S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a service.  <a href="classServiceReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceReferenceBase.html">ServiceReferenceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a service.  <a href="classServiceReferenceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceRegistration.html">ServiceRegistration&lt; I1, Interfaces &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registered service.  <a href="classServiceRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceRegistrationBase.html">ServiceRegistrationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registered service.  <a href="classServiceRegistrationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTrackedTypeTraitsBase.html">TrackedTypeTraitsBase&lt; T, TTT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class template for type traits for objects tracked by a <a class="el" href="classServiceTracker.html" title="The ServiceTracker class simplifies using services from the framework&#39;s service registry. ">ServiceTracker</a> instance.  <a href="structTrackedTypeTraitsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTrackedTypeTraits_3_01S_00_01T_01_5_01_4.html">TrackedTypeTraits&lt; S, T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default type traits for custom tracked objects of pointer type.  <a href="structTrackedTypeTraits_3_01S_00_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classServiceTracker.html">ServiceTracker&lt; S, TTT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classServiceTracker.html" title="The ServiceTracker class simplifies using services from the framework&#39;s service registry. ">ServiceTracker</a></code> class simplifies using services from the framework's service registry.  <a href="classServiceTracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structServiceTrackerCustomizer.html">ServiceTrackerCustomizer&lt; S, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structServiceTrackerCustomizer.html" title="The ServiceTrackerCustomizer interface allows a ServiceTracker to customize the service objects that ...">ServiceTrackerCustomizer</a></code> interface allows a <code><a class="el" href="classServiceTracker.html" title="The ServiceTracker class simplifies using services from the framework&#39;s service registry. ">ServiceTracker</a></code> to customize the service objects that are tracked.  <a href="structServiceTrackerCustomizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga932a21356962fd94885680e1cc7a388c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga932a21356962fd94885680e1cc7a388c">US_EXPORT_MODULE_ACTIVATOR</a>(_activator_type)</td></tr>
<tr class="memdesc:ga932a21356962fd94885680e1cc7a388c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a module activator class.  <a href="#ga932a21356962fd94885680e1cc7a388c">More...</a><br /></td></tr>
<tr class="separator:ga932a21356962fd94885680e1cc7a388c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031e6ed85b97df5b0a5ef7eac8b2a0b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga031e6ed85b97df5b0a5ef7eac8b2a0b8">US_INITIALIZE_STATIC_MODULE</a>(_module_name)</td></tr>
<tr class="memdesc:ga031e6ed85b97df5b0a5ef7eac8b2a0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a static module.  <a href="#ga031e6ed85b97df5b0a5ef7eac8b2a0b8">More...</a><br /></td></tr>
<tr class="separator:ga031e6ed85b97df5b0a5ef7eac8b2a0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631aa8524b092cd0aaaaab09c8166e91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga631aa8524b092cd0aaaaab09c8166e91">US_IMPORT_MODULE</a>(_module_name)</td></tr>
<tr class="memdesc:ga631aa8524b092cd0aaaaab09c8166e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a static module.  <a href="#ga631aa8524b092cd0aaaaab09c8166e91">More...</a><br /></td></tr>
<tr class="separator:ga631aa8524b092cd0aaaaab09c8166e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef0ba0e204d81331653e0fae5dc48ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gafef0ba0e204d81331653e0fae5dc48ec">US_INITIALIZE_MODULE</a></td></tr>
<tr class="memdesc:gafef0ba0e204d81331653e0fae5dc48ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates initialization code for a module.  <a href="#gafef0ba0e204d81331653e0fae5dc48ec">More...</a><br /></td></tr>
<tr class="separator:gafef0ba0e204d81331653e0fae5dc48ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c1340dcd99d403c8da0c52b8db30bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gad5c1340dcd99d403c8da0c52b8db30bb">US_DECLARE_SERVICE_INTERFACE</a>(_service_interface_type,  _service_interface_id)</td></tr>
<tr class="memdesc:gad5c1340dcd99d403c8da0c52b8db30bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a service interface id.  <a href="#gad5c1340dcd99d403c8da0c52b8db30bb">More...</a><br /></td></tr>
<tr class="separator:gad5c1340dcd99d403c8da0c52b8db30bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5b79f53257c6f566b36781eca6af9beb"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a></td></tr>
<tr class="memdesc:ga5b79f53257c6f566b36781eca6af9beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map containing interfaces ids and their corresponding service object pointers.  <a href="#ga5b79f53257c6f566b36781eca6af9beb">More...</a><br /></td></tr>
<tr class="separator:ga5b79f53257c6f566b36781eca6af9beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a24ce4efc225528de1094c52ea3765"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map&lt; std::string, <a class="el" href="classAny.html">Any</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gaf8a24ce4efc225528de1094c52ea3765">ServiceProperties</a></td></tr>
<tr class="memdesc:gaf8a24ce4efc225528de1094c52ea3765"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash table with std::string as the key type and <a class="el" href="classAny.html" title="An Any class represents a general type and is capable of storing any type, supporting type-safe extra...">Any</a> as the value type.  <a href="#gaf8a24ce4efc225528de1094c52ea3765">More...</a><br /></td></tr>
<tr class="separator:gaf8a24ce4efc225528de1094c52ea3765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1c95fc8d955f6057269eb4f348caba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classServiceReference.html">ServiceReference</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gaeb1c95fc8d955f6057269eb4f348caba">ServiceReferenceU</a></td></tr>
<tr class="memdesc:gaeb1c95fc8d955f6057269eb4f348caba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A service reference of unknown type, which is not bound to any interface identifier.  <a href="#gaeb1c95fc8d955f6057269eb4f348caba">More...</a><br /></td></tr>
<tr class="separator:gaeb1c95fc8d955f6057269eb4f348caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be3a427a87d460600d4aa9f36a039e4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga7be3a427a87d460600d4aa9f36a039e4">ServiceRegistrationU</a></td></tr>
<tr class="memdesc:ga7be3a427a87d460600d4aa9f36a039e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A service registration object of unknown type.  <a href="#ga7be3a427a87d460600d4aa9f36a039e4">More...</a><br /></td></tr>
<tr class="separator:ga7be3a427a87d460600d4aa9f36a039e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1606cbd5a80d1e6c1167191fa15f15dd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga1606cbd5a80d1e6c1167191fa15f15dd">ModuleEvent::Type</a> { <br />
&#160;&#160;<a class="el" href="group__MicroServices.html#gga1606cbd5a80d1e6c1167191fa15f15dda6fe6d620f5fe0941f632acc1d48ebfa4">ModuleEvent::LOADED</a>, 
<a class="el" href="group__MicroServices.html#gga1606cbd5a80d1e6c1167191fa15f15dda48c48c852469acf3fdff4188fd2f4bd7">ModuleEvent::UNLOADED</a>, 
<a class="el" href="group__MicroServices.html#gga1606cbd5a80d1e6c1167191fa15f15ddaa89d7f56fa94eb5b82e08f0119ca884d">ModuleEvent::LOADING</a>, 
<a class="el" href="group__MicroServices.html#gga1606cbd5a80d1e6c1167191fa15f15ddabdd2e44f9bed4bd929015d6b97e5691f">ModuleEvent::UNLOADING</a>, 
<br />
&#160;&#160;<a class="el" href="group__MicroServices.html#gga1606cbd5a80d1e6c1167191fa15f15dda7d3b1984011099ebcd6426072e746e3a">ModuleEvent::INSTALLED</a>, 
<a class="el" href="group__MicroServices.html#gga1606cbd5a80d1e6c1167191fa15f15dda2ee243f3d4e5aebbda1ad64b66125ddc">ModuleEvent::UNINSTALLED</a>
<br />
 }</td></tr>
<tr class="separator:ga1606cbd5a80d1e6c1167191fa15f15dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7426fe742bd938523b64d43c232a49f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gae7426fe742bd938523b64d43c232a49f">ServiceEvent::Type</a> { <a class="el" href="group__MicroServices.html#ggae7426fe742bd938523b64d43c232a49fa658bb6e21586fc2d75ca841244199cd2">ServiceEvent::REGISTERED</a>, 
<a class="el" href="group__MicroServices.html#ggae7426fe742bd938523b64d43c232a49fa25995ae997a4ee33c892e430a1fd2ca4">ServiceEvent::MODIFIED</a>, 
<a class="el" href="group__MicroServices.html#ggae7426fe742bd938523b64d43c232a49fa2727d97ff0e689285e6364afe42ecf81">ServiceEvent::UNREGISTERING</a>, 
<a class="el" href="group__MicroServices.html#ggae7426fe742bd938523b64d43c232a49fab484788a8da6e1d61d07e6014044c6fc">ServiceEvent::MODIFIED_ENDMATCH</a>
 }</td></tr>
<tr class="separator:gae7426fe742bd938523b64d43c232a49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5748dfd1ef3cabb9efc14e65246e0281"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga5748dfd1ef3cabb9efc14e65246e0281">ServiceException::Type</a> { <br />
&#160;&#160;<a class="el" href="group__MicroServices.html#gga5748dfd1ef3cabb9efc14e65246e0281aa655fb17e2cc9f83c7a49d2a62e912d6">ServiceException::UNSPECIFIED</a>, 
<a class="el" href="group__MicroServices.html#gga5748dfd1ef3cabb9efc14e65246e0281a022b3323d01bda453133cb429882f5fd">ServiceException::UNREGISTERED</a>, 
<a class="el" href="group__MicroServices.html#gga5748dfd1ef3cabb9efc14e65246e0281af38eb31efed8ca7838846e3f7907425c">ServiceException::FACTORY_ERROR</a>, 
<a class="el" href="group__MicroServices.html#gga5748dfd1ef3cabb9efc14e65246e0281a0219558d49a978fbf1038c81b7e60fd6">ServiceException::FACTORY_EXCEPTION</a>, 
<br />
&#160;&#160;<a class="el" href="group__MicroServices.html#gga5748dfd1ef3cabb9efc14e65246e0281aaf27c97fef3133bc770946f694b1f586">ServiceException::REMOTE</a>, 
<a class="el" href="group__MicroServices.html#gga5748dfd1ef3cabb9efc14e65246e0281ae49d63a1b468defe50d6f3a58b68817a">ServiceException::FACTORY_RECURSION</a>
<br />
 }</td></tr>
<tr class="separator:ga5748dfd1ef3cabb9efc14e65246e0281"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga41b3658ea10e3163c894439dc62bdfb4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classModuleContext.html">ModuleContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga41b3658ea10e3163c894439dc62bdfb4">GetModuleContext</a> ()</td></tr>
<tr class="memdesc:ga41b3658ea10e3163c894439dc62bdfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the module context of the calling module.  <a href="#ga41b3658ea10e3163c894439dc62bdfb4">More...</a><br /></td></tr>
<tr class="separator:ga41b3658ea10e3163c894439dc62bdfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d37a0ec8bfc12a11d9a2cd37326ceef"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga8d37a0ec8bfc12a11d9a2cd37326ceef">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classLDAPFilter.html">LDAPFilter</a> &amp;filter)</td></tr>
<tr class="separator:ga8d37a0ec8bfc12a11d9a2cd37326ceef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac382698c14344ab194e8990f235533da"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gac382698c14344ab194e8990f235533da">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classModule.html">Module</a> &amp;module)</td></tr>
<tr class="separator:gac382698c14344ab194e8990f235533da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa91d337384c529814a8e55b4bae04435"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gaa91d337384c529814a8e55b4bae04435">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classModule.html">Module</a> const *module)</td></tr>
<tr class="separator:gaa91d337384c529814a8e55b4bae04435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a451ec798c40c43e9ac14368e2a3b7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga00a451ec798c40c43e9ac14368e2a3b7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classModuleResource.html">ModuleResource</a> &amp;resource)</td></tr>
<tr class="separator:ga00a451ec798c40c43e9ac14368e2a3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a46aabaac672a2b3ee7e3788d0c480b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga0a46aabaac672a2b3ee7e3788d0c480b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classModuleVersion.html">ModuleVersion</a> &amp;v)</td></tr>
<tr class="separator:ga0a46aabaac672a2b3ee7e3788d0c480b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0babe6da6f1e26b30f9f3967591ee08"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf0babe6da6f1e26b30f9f3967591ee08"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gaf0babe6da6f1e26b30f9f3967591ee08">us_service_interface_iid</a> ()</td></tr>
<tr class="memdesc:gaf0babe6da6f1e26b30f9f3967591ee08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique id for a given type.  <a href="#gaf0babe6da6f1e26b30f9f3967591ee08">More...</a><br /></td></tr>
<tr class="separator:gaf0babe6da6f1e26b30f9f3967591ee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c5f0b69c46d1290a5c6d5d7826f2d30"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:ga5c5f0b69c46d1290a5c6d5d7826f2d30"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga5c5f0b69c46d1290a5c6d5d7826f2d30">ExtractInterface</a> (const <a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a> &amp;map)</td></tr>
<tr class="memdesc:ga5c5f0b69c46d1290a5c6d5d7826f2d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a service interface pointer from a given InterfaceMap instance.  <a href="#ga5c5f0b69c46d1290a5c6d5d7826f2d30">More...</a><br /></td></tr>
<tr class="separator:ga5c5f0b69c46d1290a5c6d5d7826f2d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8708fba052b80c7b5d482e4ac2ff1b48"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga8708fba052b80c7b5d482e4ac2ff1b48">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classServiceReferenceBase.html">ServiceReferenceBase</a> &amp;serviceRef)</td></tr>
<tr class="separator:ga8708fba052b80c7b5d482e4ac2ff1b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1153d893ef8418fad576622cc8d27f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#gafe1153d893ef8418fad576622cc8d27f">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="group__MicroServices.html#ga1606cbd5a80d1e6c1167191fa15f15dd">ModuleEvent::Type</a> eventType)</td></tr>
<tr class="separator:gafe1153d893ef8418fad576622cc8d27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b999145fafb503799bc16d96e8d657"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga92b999145fafb503799bc16d96e8d657">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classModuleEvent.html">ModuleEvent</a> &amp;event)</td></tr>
<tr class="separator:ga92b999145fafb503799bc16d96e8d657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977299de2ca81067d9918428dfd9f552"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga977299de2ca81067d9918428dfd9f552">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="group__MicroServices.html#gae7426fe742bd938523b64d43c232a49f">ServiceEvent::Type</a> &amp;type)</td></tr>
<tr class="separator:ga977299de2ca81067d9918428dfd9f552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b5c0f972a7c6b0ed0e73be75599e4e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga45b5c0f972a7c6b0ed0e73be75599e4e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classServiceEvent.html">ServiceEvent</a> &amp;event)</td></tr>
<tr class="separator:ga45b5c0f972a7c6b0ed0e73be75599e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d68814673bd0adf58b8209950f23c0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga53d68814673bd0adf58b8209950f23c0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classServiceException.html">ServiceException</a> &amp;exc)</td></tr>
<tr class="separator:ga53d68814673bd0adf58b8209950f23c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cd55607df8f9ef807fd405bac466d0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga10cd55607df8f9ef807fd405bac466d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceFactory.html">ServiceFactory</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga10cd55607df8f9ef807fd405bac466d0">ToFactory</a> (T &amp;factory, typename std::enable_if&lt; std::is_class&lt; T &gt;::value, T &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:ga10cd55607df8f9ef807fd405bac466d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the argument to a <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services. ">ServiceFactory</a></code> pointer.  <a href="#ga10cd55607df8f9ef807fd405bac466d0">More...</a><br /></td></tr>
<tr class="separator:ga10cd55607df8f9ef807fd405bac466d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465ca18b5205ff432e939bd4ac573faf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga465ca18b5205ff432e939bd4ac573faf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceFactory.html">ServiceFactory</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MicroServices.html#ga465ca18b5205ff432e939bd4ac573faf">ToFactory</a> (T factory, typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &amp;&amp;std::is_class&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:ga465ca18b5205ff432e939bd4ac573faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the argument to a <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services. ">ServiceFactory</a></code> pointer.  <a href="#ga465ca18b5205ff432e939bd4ac573faf">More...</a><br /></td></tr>
<tr class="separator:ga465ca18b5205ff432e939bd4ac573faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This category includes classes related to the C++ Micro Services component. </p>
<p>The C++ Micro Services component provides a dynamic service registry based on the service layer as specified in the OSGi R4.2 specifications. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gad5c1340dcd99d403c8da0c52b8db30bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define US_DECLARE_SERVICE_INTERFACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_service_interface_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_service_interface_id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a service interface id. </p>
<p>This macro associates the given identifier <em>_service_interface_id</em> (a string literal) to the interface class called _service_interface_type. The Identifier must be unique. For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;usServiceInterface.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;struct ISomeInterace { ... };</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;US_DECLARE_SERVICE_INTERFACE(ISomeInterface, &quot;com.mycompany.service.ISomeInterface/1.0&quot;)</div>
</div><!-- fragment --><p>The usage of this macro is optional and the service interface id which is automatically associated with any type is usually good enough (the demangled type name). However, care must be taken if the default id is compared with a string literal hard-coding a service interface id. E.g. the default id for templated types in the STL may differ between platforms. For user-defined types and templates the ids are typically consistent, but platform specific default template arguments will lead to different ids.</p>
<p>This macro is normally used right after the class definition for _service_interface_type, in a header file.</p>
<p>If you want to use <a class="el" href="group__MicroServices.html#gad5c1340dcd99d403c8da0c52b8db30bb" title="Declare a service interface id. ">US_DECLARE_SERVICE_INTERFACE</a> with interface classes declared in a namespace then you have to make sure the <a class="el" href="group__MicroServices.html#gad5c1340dcd99d403c8da0c52b8db30bb" title="Declare a service interface id. ">US_DECLARE_SERVICE_INTERFACE</a> macro call is not inside a namespace though. For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;usServiceInterface.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;namespace Foo</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;{</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  struct ISomeInterface { ... };</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;US_DECLARE_SERVICE_INTERFACE(Foo::ISomeInterface, &quot;com.mycompany.service.ISomeInterface/1.0&quot;)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_service_interface_type</td><td>The service interface type. </td></tr>
    <tr><td class="paramname">_service_interface_id</td><td>A string literal representing a globally unique identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga932a21356962fd94885680e1cc7a388c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define US_EXPORT_MODULE_ACTIVATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_activator_type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a module activator class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_activator_type</td><td>The fully-qualified type-name of the module activator class.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this macro after the definition of your module activator to make it accessible by the CppMicroServices library.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyActivator : <span class="keyword">public</span> <a class="code" href="structModuleActivator.html">ModuleActivator</a></div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structModuleActivator.html#a1db3f85c15a814a5918eb22725229967">Load</a>(<a class="code" href="classModuleContext.html">ModuleContext</a>* <span class="comment">/*context*/</span>)</div>
<div class="line">  { <span class="comment">/* register stuff */</span> }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structModuleActivator.html#a410a3f54b7cad990e8d670450677218c">Unload</a>(<a class="code" href="classModuleContext.html">ModuleContext</a>* <span class="comment">/*context*/</span>)</div>
<div class="line">  { <span class="comment">/* cleanup */</span> }</div>
<div class="line"></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MicroServices.html#ga932a21356962fd94885680e1cc7a388c">US_EXPORT_MODULE_ACTIVATOR</a>(MyActivator)</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga631aa8524b092cd0aaaaab09c8166e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define US_IMPORT_MODULE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_module_name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a static module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_module_name</td><td>The name of the module to import.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro imports the static module named <code>_module_name</code>.</p>
<p>Inserting this macro into your application's source code will allow you to make use of a static module. It will initialize the static module and calls its <a class="el" href="structModuleActivator.html" title="Customizes the starting and stopping of a CppMicroServices module. ">ModuleActivator</a>. If the module does not provide an activator, use the <a class="el" href="group__MicroServices.html#ga031e6ed85b97df5b0a5ef7eac8b2a0b8" title="Initialize a static module. ">US_INITIALIZE_STATIC_MODULE</a> macro instead. Do not forget to actually link the static module to the importing executable or shared library.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;usModuleImport.h&gt;</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MicroServices.html#ga631aa8524b092cd0aaaaab09c8166e91">US_IMPORT_MODULE</a>(MyStaticModule1)</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__MicroServices.html#ga031e6ed85b97df5b0a5ef7eac8b2a0b8" title="Initialize a static module. ">US_INITIALIZE_STATIC_MODULE</a> </dd>
<dd>
US_IMPORT_MODULE_RESOURCES </dd>
<dd>
<a class="el" href="MicroServices_StaticModules.html">Static Modules</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafef0ba0e204d81331653e0fae5dc48ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define US_INITIALIZE_MODULE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates initialization code for a module. </p>
<p>Each module which wants to register itself with the CppMicroServices library has to put a call to this macro in one of its source files. Further, the module's source files must be compiled with the <code>US_MODULE_NAME</code> pre-processor definition set to a module-unique identifier.</p>
<p>Calling the <code>US_INITIALIZE_MODULE</code> macro will initialize the module for use with the CppMicroServices library, using a default auto-load directory named after the <code>US_MODULE_NAME</code> definition.</p>
<dl class="section see"><dt>See also</dt><dd>MicroServices_AutoLoading</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you are using CMake, consider using the provided CMake macro <code><a class="el" href="group__MicroServicesCMake.html#ga9b72f7ba11ea53a3039893522d318168" title="Generate a source file which handles proper initialization of a module. ">usFunctionGenerateModuleInit()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga031e6ed85b97df5b0a5ef7eac8b2a0b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define US_INITIALIZE_STATIC_MODULE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_module_name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a static module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_module_name</td><td>The name of the module to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro initializes the static module named <code>_module_name</code>.</p>
<p>If the module provides an activator, use the <a class="el" href="group__MicroServices.html#ga631aa8524b092cd0aaaaab09c8166e91" title="Import a static module. ">US_IMPORT_MODULE</a> macro instead, to ensure that the activator is called. Do not forget to actually link the static module to the importing executable or shared library.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__MicroServices.html#ga631aa8524b092cd0aaaaab09c8166e91" title="Import a static module. ">US_IMPORT_MODULE</a> </dd>
<dd>
US_IMPORT_MODULE_RESOURCES </dd>
<dd>
<a class="el" href="MicroServices_StaticModules.html">Static Modules</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5b79f53257c6f566b36781eca6af9beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, void*&gt; <a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map containing interfaces ids and their corresponding service object pointers. </p>
<p>InterfaceMap instances represent a complete service object which implementes one or more service interfaces. For each implemented service interface, there is an entry in the map with the key being the service interface id and the value a pointer to the service interface implementation.</p>
<p>To create InterfaceMap instances, use the <a class="el" href="structMakeInterfaceMap.html" title="Helper class for constructing InterfaceMap instances based on service implementations or service fact...">MakeInterfaceMap</a> helper class.</p>
<dl class="section note"><dt>Note</dt><dd>This is a low-level type and should only rarely be used.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structMakeInterfaceMap.html" title="Helper class for constructing InterfaceMap instances based on service implementations or service fact...">MakeInterfaceMap</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8a24ce4efc225528de1094c52ea3765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;std::string, <a class="el" href="classAny.html">Any</a>&gt; <a class="el" href="group__MicroServices.html#gaf8a24ce4efc225528de1094c52ea3765">ServiceProperties</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A hash table with std::string as the key type and <a class="el" href="classAny.html" title="An Any class represents a general type and is capable of storing any type, supporting type-safe extra...">Any</a> as the value type. </p>
<p>It is typically used for passing service properties to <a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">ModuleContext::RegisterService</a>. </p>

</div>
</div>
<a class="anchor" id="gaeb1c95fc8d955f6057269eb4f348caba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classServiceReference.html">ServiceReference</a>&lt;void&gt; <a class="el" href="classServiceReference.html">ServiceReferenceU</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A service reference of unknown type, which is not bound to any interface identifier. </p>

</div>
</div>
<a class="anchor" id="ga7be3a427a87d460600d4aa9f36a039e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt;void&gt; <a class="el" href="group__MicroServices.html#ga7be3a427a87d460600d4aa9f36a039e4">ServiceRegistrationU</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A service registration object of unknown type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga5748dfd1ef3cabb9efc14e65246e0281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MicroServices.html#ga5748dfd1ef3cabb9efc14e65246e0281">ServiceException::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5748dfd1ef3cabb9efc14e65246e0281aa655fb17e2cc9f83c7a49d2a62e912d6"></a>UNSPECIFIED&#160;</td><td class="fielddoc">
<p>No exception type is unspecified. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5748dfd1ef3cabb9efc14e65246e0281a022b3323d01bda453133cb429882f5fd"></a>UNREGISTERED&#160;</td><td class="fielddoc">
<p>The service has been unregistered. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5748dfd1ef3cabb9efc14e65246e0281af38eb31efed8ca7838846e3f7907425c"></a>FACTORY_ERROR&#160;</td><td class="fielddoc">
<p>The service factory produced an invalid service object. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5748dfd1ef3cabb9efc14e65246e0281a0219558d49a978fbf1038c81b7e60fd6"></a>FACTORY_EXCEPTION&#160;</td><td class="fielddoc">
<p>The service factory threw an exception. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5748dfd1ef3cabb9efc14e65246e0281aaf27c97fef3133bc770946f694b1f586"></a>REMOTE&#160;</td><td class="fielddoc">
<p>An error occurred invoking a remote service. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5748dfd1ef3cabb9efc14e65246e0281ae49d63a1b468defe50d6f3a58b68817a"></a>FACTORY_RECURSION&#160;</td><td class="fielddoc">
<p>The service factory resulted in a recursive call to itself for the requesting module. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga1606cbd5a80d1e6c1167191fa15f15dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MicroServices.html#ga1606cbd5a80d1e6c1167191fa15f15dd">ModuleEvent::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1606cbd5a80d1e6c1167191fa15f15dda6fe6d620f5fe0941f632acc1d48ebfa4"></a>LOADED&#160;</td><td class="fielddoc">
<p>The module has been loaded. </p>
<p>The module's <a class="el" href="structModuleActivator.html#a1db3f85c15a814a5918eb22725229967">ModuleActivator Load</a> method has been executed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1606cbd5a80d1e6c1167191fa15f15dda48c48c852469acf3fdff4188fd2f4bd7"></a>UNLOADED&#160;</td><td class="fielddoc">
<p>The module has been unloaded. </p>
<p>The module's <a class="el" href="structModuleActivator.html#a410a3f54b7cad990e8d670450677218c">ModuleActivator Unload</a> method has been executed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1606cbd5a80d1e6c1167191fa15f15ddaa89d7f56fa94eb5b82e08f0119ca884d"></a>LOADING&#160;</td><td class="fielddoc">
<p>The module is about to be loaded. </p>
<p>The module's <a class="el" href="structModuleActivator.html#a1db3f85c15a814a5918eb22725229967">ModuleActivator Load</a> method is about to be called. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1606cbd5a80d1e6c1167191fa15f15ddabdd2e44f9bed4bd929015d6b97e5691f"></a>UNLOADING&#160;</td><td class="fielddoc">
<p>The module is about to be unloaded. </p>
<p>The module's <a class="el" href="structModuleActivator.html#a410a3f54b7cad990e8d670450677218c">ModuleActivator Unload</a> method is about to be called. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1606cbd5a80d1e6c1167191fa15f15dda7d3b1984011099ebcd6426072e746e3a"></a>INSTALLED&#160;</td><td class="fielddoc">
<p>The bundle has been installed. </p>
<p>The bundle has been installed by the <a class="el" href="classFramework.html" title="The CppMicroServices Framework. ">Framework</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1606cbd5a80d1e6c1167191fa15f15dda2ee243f3d4e5aebbda1ad64b66125ddc"></a>UNINSTALLED&#160;</td><td class="fielddoc">
<p>The bundle has been uninstalled. </p>
<p>The bundle has been removed from the <a class="el" href="classFramework.html" title="The CppMicroServices Framework. ">Framework</a>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae7426fe742bd938523b64d43c232a49f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MicroServices.html#gae7426fe742bd938523b64d43c232a49f">ServiceEvent::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae7426fe742bd938523b64d43c232a49fa658bb6e21586fc2d75ca841244199cd2"></a>REGISTERED&#160;</td><td class="fielddoc">
<p>This service has been registered. </p>
<p>This event is delivered <b>after</b> the service has been registered with the framework.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">ModuleContext::RegisterService()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae7426fe742bd938523b64d43c232a49fa25995ae997a4ee33c892e430a1fd2ca4"></a>MODIFIED&#160;</td><td class="fielddoc">
<p>The properties of a registered service have been modified. </p>
<p>This event is delivered <b>after</b> the service properties have been modified.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classServiceRegistrationBase.html#a4e2865300c14dbb04e4efb955d901241" title="Updates the properties associated with a service. ">ServiceRegistration::SetProperties</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae7426fe742bd938523b64d43c232a49fa2727d97ff0e689285e6364afe42ecf81"></a>UNREGISTERING&#160;</td><td class="fielddoc">
<p>This service is in the process of being unregistered. </p>
<p>This event is delivered <b>before</b> the service has completed unregistering.</p>
<p>If a module is using a service that is <code>UNREGISTERING</code>, the module should release its use of the service when it receives this event. If the module does not release its use of the service when it receives this event, the framework will automatically release the module's use of the service while completing the service unregistration operation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classServiceRegistrationBase.html#aeae0bd412d81a0882a78d7881db47a2a" title="Unregisters a service. ">ServiceRegistration::Unregister</a> </dd>
<dd>
<a class="el" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41" title="Releases the service object referenced by the specified ServiceReference object. ">ModuleContext::UngetService</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae7426fe742bd938523b64d43c232a49fab484788a8da6e1d61d07e6014044c6fc"></a>MODIFIED_ENDMATCH&#160;</td><td class="fielddoc">
<p>The properties of a registered service have been modified and the new properties no longer match the listener's filter. </p>
<p>This event is delivered <b>after</b> the service properties have been modified. This event is only delivered to listeners which were added with a non-empty filter where the filter matched the service properties prior to the modification but the filter does not match the modified service properties.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classServiceRegistrationBase.html#a4e2865300c14dbb04e4efb955d901241" title="Updates the properties associated with a service. ">ServiceRegistration::SetProperties</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5c5f0b69c46d1290a5c6d5d7826f2d30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Interface* ExtractInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a service interface pointer from a given InterfaceMap instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>a InterfaceMap instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface pointer for the service interface id of the <code>I1</code> interface type or NULL if <code>map</code> does not contain an entry for the given type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structMakeInterfaceMap.html" title="Helper class for constructing InterfaceMap instances based on service implementations or service fact...">MakeInterfaceMap</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga41b3658ea10e3163c894439dc62bdfb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classModuleContext.html">ModuleContext</a>* GetModuleContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the module context of the calling module. </p>
<p>This function allows easy access to the <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a> instance from inside a C++ Micro Services module.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a> of the calling module. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53d68814673bd0adf58b8209950f23c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classServiceException.html">ServiceException</a> &amp;&#160;</td>
          <td class="paramname"><em>exc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gafe1153d893ef8418fad576622cc8d27f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MicroServices.html#ga1606cbd5a80d1e6c1167191fa15f15dd">ModuleEvent::Type</a>&#160;</td>
          <td class="paramname"><em>eventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga92b999145fafb503799bc16d96e8d657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModuleEvent.html">ModuleEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8d37a0ec8bfc12a11d9a2cd37326ceef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLDAPFilter.html">LDAPFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga977299de2ca81067d9918428dfd9f552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#gae7426fe742bd938523b64d43c232a49f">ServiceEvent::Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga45b5c0f972a7c6b0ed0e73be75599e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classServiceEvent.html">ServiceEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8708fba052b80c7b5d482e4ac2ff1b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classServiceReferenceBase.html">ServiceReferenceBase</a> &amp;&#160;</td>
          <td class="paramname"><em>serviceRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0a46aabaac672a2b3ee7e3788d0c480b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModuleVersion.html">ModuleVersion</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga00a451ec798c40c43e9ac14368e2a3b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModuleResource.html">ModuleResource</a> &amp;&#160;</td>
          <td class="paramname"><em>resource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac382698c14344ab194e8990f235533da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModule.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa91d337384c529814a8e55b4bae04435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModule.html">Module</a> const *&#160;</td>
          <td class="paramname"><em>module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga10cd55607df8f9ef807fd405bac466d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceFactory.html">ServiceFactory</a>* ToFactory </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_class&lt; T &gt;::value, T &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast the argument to a <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services. ">ServiceFactory</a></code> pointer. </p>
<p>Useful when calling <code><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">ModuleContext::RegisterService</a></code> with a service factory, for example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;MyServiceFactory* factory;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;context-&gt;RegisterService&lt;ISomeInterface&gt;(ToFactory(factory));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The service factory. May be a pointer or reference type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services. ">ServiceFactory</a></code> pointer to the passed <code>factory</code> instance.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classModuleContext.html#a6acaff55bce54c49d755f7641d7ebb1c" title="Registers the specified service factory as a service with the specified properties using the specifie...">ModuleContext::RegisterService(ServiceFactory* factory, const ServiceProperties&amp; properties)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga465ca18b5205ff432e939bd4ac573faf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceFactory.html">ServiceFactory</a>* ToFactory </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &amp;&amp;std::is_class&lt; typename std::remove_pointer&lt; T &gt;::type &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast the argument to a <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services. ">ServiceFactory</a></code> pointer. </p>
<p>Useful when calling <code><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">ModuleContext::RegisterService</a></code> with a service factory, for example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;MyServiceFactory* factory;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;context-&gt;RegisterService&lt;ISomeInterface&gt;(ToFactory(factory));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The service factory. May be a pointer or reference type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services. ">ServiceFactory</a></code> pointer to the passed <code>factory</code> instance.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classModuleContext.html#a6acaff55bce54c49d755f7641d7ebb1c" title="Registers the specified service factory as a service with the specified properties using the specifie...">ModuleContext::RegisterService(ServiceFactory* factory, const ServiceProperties&amp; properties)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0babe6da6f1e26b30f9f3967591ee08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string us_service_interface_iid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a unique id for a given type. </p>
<p>By default, the demangled name of <code>T</code> is returned.</p>
<p>This template method may be specialized directly or be using the macro <a class="el" href="group__MicroServices.html#gad5c1340dcd99d403c8da0c52b8db30bb" title="Declare a service interface id. ">US_DECLARE_SERVICE_INTERFACE</a> to return a custom id for each service interface.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The service interface type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique id for the service interface type T. </dd></dl>

</div>
</div>
</div><!-- contents -->

  <hr class="footer"/>
  <address class="footer"><small>Generated on Tue Oct 6 2015 for C++ Micro Services 2.99.0 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.9.1
</small></address>
