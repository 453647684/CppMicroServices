---
layout: default
title: Emulating singletons with micro services
---
  <head>
    <title>C++ Micro Services: Emulating singletons with micro services</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
  </head>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="MicroServices_Tutorials.html">Tutorials</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Emulating singletons with micro services </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="MicroServices_EmulateSingleton_1"></a>
Meyers Singleton</h1>
<p>Singletons are a well known pattern to ensure that only one instance of a class exists during the whole life-time of the application. A self-deleting variant is the "Meyers Singleton":</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SingletonOne</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> SingletonOne&amp; GetInstance();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Just some member</span></div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">  SingletonOne();</div>
<div class="line">  ~SingletonOne();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Disable copy constructor and assignment operator.</span></div>
<div class="line">  SingletonOne(<span class="keyword">const</span> SingletonOne&amp;);</div>
<div class="line">  SingletonOne&amp; operator=(<span class="keyword">const</span> SingletonOne&amp;);</div>
<div class="line">};</div>
</div><!-- fragment --><p> where the GetInstance() method is implemented as</p>
<div class="fragment"><div class="line">SingletonOne&amp; SingletonOne::GetInstance()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> SingletonOne instance;</div>
<div class="line">  <span class="keywordflow">return</span> instance;</div>
<div class="line">}</div>
</div><!-- fragment --><p> If such a singleton is accessed during static deinitialization (which happens during unloading of shared libraries or application termination), your program might crash or even worse, exhibit undefined behavior, depending on your compiler and/or weekday. Such an access might happen in destructors of other objects with static life-time.</p>
<p>For example, suppose that SingletonOne needs to call a second Meyers singleton during destruction:</p>
<div class="fragment"><div class="line">SingletonOne::~SingletonOne()</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;SingletonTwo::b = &quot;</span> &lt;&lt; SingletonTwo::GetInstance().b &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> If SingletonTwo was destroyed before SingletonOne, this leads to the mentioned problems. Note that this problem only occurs for static objects defined in the same shared library.</p>
<p>Since you cannot reliably control the destruction order of global static objects, you must not introduce dependencies between them during static deinitialization. This is one reason why one should consider an alternative approach to singletons (unless you can absolutely make sure that nothing in your shared library will introduce such dependencies. Never.)</p>
<p>Of course you could use something like a "Phoenix singleton" but that will have other drawbacks in certain scenarios. Returning pointers instead of references in GetInstance() would open up the possibility to return NULL, but than again this would not help if you require a non-NULL instance in your destructor.</p>
<p>Another reason for an alternative approach is that singletons are usually not meant to be singletons for eternity. If your design evolves, you might hit a point where you suddenly need multiple instances of your singleton.</p>
<h1><a class="anchor" id="MicroServices_EmulateSingleton_2"></a>
Singletons as a service</h1>
<p>The C++ Micro Services can be used to emulate the singleton pattern using a non-singleton class. This leaves room for future extensions without the need for heavy refactoring. Additionally, it gives you full control about the construction and destruction order of your "singletons" inside your shared library or executable, making it possible to have dependencies between them during destruction.</p>
<h2><a class="anchor" id="MicroServices_EmulateSingleton_2_1"></a>
Converting a classic singleton</h2>
<p>We modify the previous SingletonOne class such that it internally uses the micro services API. The changes are discussed in detail below.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SingletonOneService : <span class="keyword">public</span> US_BASECLASS_NAME</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  <span class="comment">// This will return a SingletonOneService instance with the</span></div>
<div class="line">  <span class="comment">// lowest service id at the time this method was called the first</span></div>
<div class="line">  <span class="comment">// time and returned a non-null value (which is usually the instance</span></div>
<div class="line">  <span class="comment">// which was registered first). A null-pointer is returned if no</span></div>
<div class="line">  <span class="comment">// instance was registered yet.</span></div>
<div class="line">  <span class="keyword">static</span> SingletonOneService* GetInstance();</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Only our module activator class should be able to instantiate</span></div>
<div class="line">  <span class="comment">// a SingletonOneService object.</span></div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>MyActivator;</div>
<div class="line"></div>
<div class="line">  SingletonOneService();</div>
<div class="line">  ~SingletonOneService();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Disable copy constructor and assignment operator.</span></div>
<div class="line">  SingletonOneService(<span class="keyword">const</span> SingletonOneService&amp;);</div>
<div class="line">  SingletonOneService&amp; operator=(<span class="keyword">const</span> SingletonOneService&amp;);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MicroServices.html#gad5c1340dcd99d403c8da0c52b8db30bb" title="Declare a CppMicroServices service interface.">US_DECLARE_SERVICE_INTERFACE</a>(SingletonOneService, <span class="stringliteral">&quot;org.cppmicroservices.snippet.SingletonOneService&quot;</span>)</div>
</div><!-- fragment --><ul>
<li>Inherit us::Base: All service implementations (not their interfaces) must inherit from us::Base or from the base class as specified in the CMake configuration. In the implementation above, the class SingletonOneService provides the implementation as well as the interface.</li>
<li>Friend activator: We move the responsibility of constructing instances of SingletonOneService from the GetInstance() method to the module activator.</li>
<li>Service interface declaration: Because the SingletonOneService class introduces a new service interface, it must be registered under a unique name using the helper macro US_DECLARE_SERVICE_INTERFACE.</li>
</ul>
<p>Let's have a look at the modified GetInstance() and ~SingletonOneService() methods.</p>
<div class="fragment"><div class="line">SingletonOneService* SingletonOneService::GetInstance()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classServiceReference.html">ServiceReference</a> serviceRef;</div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classModuleContext.html">ModuleContext</a>* context = <a class="code" href="group__MicroServices.html#ga80e18861e658c6523a46beba5c3ac208" title="Returns the module context of the calling module.">GetModuleContext</a>();</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!serviceRef)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This is either the first time GetInstance() was called,</span></div>
<div class="line">    <span class="comment">// or a SingletonOneService instance has not yet been registered.</span></div>
<div class="line">    serviceRef = context-&gt;<a class="code" href="classModuleContext.html#ad4e3f72bad1067aba49283e851448253">GetServiceReference</a>&lt;SingletonOneService&gt;();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (serviceRef)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// We have a valid service reference. It always points to the service</span></div>
<div class="line">    <span class="comment">// with the lowest id (usually the one which was registered first).</span></div>
<div class="line">    <span class="comment">// This still might return a null pointer, if all SingletonOneService</span></div>
<div class="line">    <span class="comment">// instances have been unregistered (during unloading of the library,</span></div>
<div class="line">    <span class="comment">// for example).</span></div>
<div class="line">    <span class="keywordflow">return</span> context-&gt;<a class="code" href="classModuleContext.html#a2bdfe2bcbae824b0cd6aa79bc4489850">GetService</a>&lt;SingletonOneService&gt;(serviceRef);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// No SingletonOneService instance was registered yet.</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The inline comments should explain the details. Note that we now had to change the return type to a pointer, instead of a reference as in the classic singleton. This is necessary since we can no longer guarantee that an instance always exists. Clients of the GetInstance() method must check for null pointers and react appropriately.</p>
<dl class="section warning"><dt>Warning</dt><dd>Newly created "singletons" should not expose a GetInstance() method. They should be handled as proper services and hence should be retrieved by clients using the <a class="el" href="classModuleContext.html">ModuleContext</a> or <a class="el" href="classServiceTracker.html">ServiceTracker</a> API. The GetInstance() method is for migration purposes only.</dd></dl>
<div class="fragment"><div class="line">SingletonOneService::~SingletonOneService()</div>
<div class="line">{</div>
<div class="line">  SingletonTwoService* singletonTwoService = SingletonTwoService::GetInstance();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The module activator must ensure that a SingletonTwoService instance is</span></div>
<div class="line">  <span class="comment">// available during destruction of a SingletonOneService instance.</span></div>
<div class="line">  assert(singletonTwoService != 0);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;SingletonTwoService::b = &quot;</span> &lt;&lt; singletonTwoService-&gt;b &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The SingletonTwoService::GetInstance() method is implemented exactly as in SingletonOneService. Because we know that the module activator guarantees that a SingletonTwoService instance will always be available during the life-time of a SingletonOneService instance (see below), we can assert a non-null pointer. Otherwise, we would have to handle the null-pointer case.</p>
<p>The order of construction/registration and destruction/unregistration of our singletons (or any other services) is defined in the Load() and Unload() methods of the module activator.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> Load(<a class="code" href="classModuleContext.html">ModuleContext</a>* context)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// The Load() method of the module activator is called during static</span></div>
<div class="line">    <span class="comment">// initialization time of the shared library.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// First create and register a SingletonTwoService instance.</span></div>
<div class="line">    m_SingletonTwo = <span class="keyword">new</span> SingletonTwoService;</div>
<div class="line">    m_SingletonTwoReg = context-&gt;<a class="code" href="classModuleContext.html#a7399fcc65ae1625cc06e4010e9e262d6">RegisterService</a>&lt;SingletonTwoService&gt;(m_SingletonTwo);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Now the SingletonOneService constructor will get a valid</span></div>
<div class="line">    <span class="comment">// SingletonTwoService instance.</span></div>
<div class="line">    m_SingletonOne = <span class="keyword">new</span> SingletonOneService;</div>
<div class="line">    m_SingletonOneReg = context-&gt;<a class="code" href="classModuleContext.html#a7399fcc65ae1625cc06e4010e9e262d6">RegisterService</a>&lt;SingletonOneService&gt;(m_SingletonOne);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The Unload() method is defined as:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> Unload(<a class="code" href="classModuleContext.html">ModuleContext</a>* <span class="comment">/*context*/</span>)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Services are automatically unregistered during unloading of</span></div>
<div class="line">    <span class="comment">// the shared library after the call to Unload(ModuleContext*)</span></div>
<div class="line">    <span class="comment">// has returned.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Since SingletonOneService needs a non-null SingletonTwoService</span></div>
<div class="line">    <span class="comment">// instance in its destructor, we explicitly unregister and delete the</span></div>
<div class="line">    <span class="comment">// SingletonOneService instance here. This way, the SingletonOneService</span></div>
<div class="line">    <span class="comment">// destructor will still get a valid SingletonTwoService instance.</span></div>
<div class="line">    m_SingletonOneReg.Unregister();</div>
<div class="line">    <span class="keyword">delete</span> m_SingletonOne;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For singletonTwoService, we could rely on the automatic unregistering</span></div>
<div class="line">    <span class="comment">// by the service registry and on automatic deletion if you used</span></div>
<div class="line">    <span class="comment">// smart pointer reference counting. You must not delete service instances</span></div>
<div class="line">    <span class="comment">// in this method without unregistering them first.</span></div>
<div class="line">    m_SingletonTwoReg.Unregister();</div>
<div class="line">    <span class="keyword">delete</span> m_SingletonTwo;</div>
<div class="line">  }</div>
</div><!-- fragment --></div></div><!-- contents -->

  <hr class="footer"/>
  <address class="footer"><small>Generated on Mon Feb 4 2013 for C++ Micro Services 0.99.0 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.3.1
</small></address>
