---
layout: default
title: Emulating singletons with micro services
---

  <head>

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    
    
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    
    
    <style>
      #MSearchField { height: 14px; }
      #MSearchClose { top: 1px; }
    </style>

  </head>

  <div class="doxygen-header" id="top"><!-- do not remove this div! -->
  
<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">The C++ Micro Services</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Emulating singletons with micro services </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="MicroServices_EmulateSingleton_1"></a>
Meyers Singleton</h2>
<p>Singletons are a well known pattern to ensure that only one instance of a class exists during the whole life-time of the application. A self-deleting variant is the "Meyers Singleton":</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>SingletonOne
{
<span class="keyword">public</span>:

  <span class="keyword">static</span> SingletonOne&amp; GetInstance();

  <span class="comment">// Just some member</span>
  <span class="keywordtype">int</span> a;

<span class="keyword">private</span>:

  SingletonOne();
  ~SingletonOne();

  <span class="comment">// Disable copy constructor and assignment operator.</span>
  SingletonOne(<span class="keyword">const</span> SingletonOne&amp;);
  SingletonOne&amp; operator=(<span class="keyword">const</span> SingletonOne&amp;);
};
</pre></div><p> where the GetInstance() method is implemented as</p>
<div class="fragment"><pre class="fragment">SingletonOne&amp; SingletonOne::GetInstance()
{
  <span class="keyword">static</span> SingletonOne instance;
  <span class="keywordflow">return</span> instance;
}
</pre></div><p> If such a singleton is accessed during static deinitialization (which happens during unloading of shared libraries or application termination), your program might crash or even worse, exhibit undefined behavior, depending on your compiler and/or weekday. Such an access might happen in destructors of other objects with static life-time.</p>
<p>For example, suppose that SingletonOne needs to call a second Meyers singleton during destruction:</p>
<div class="fragment"><pre class="fragment">SingletonOne::~SingletonOne()
{
  std::cout &lt;&lt; <span class="stringliteral">&quot;SingletonTwo::b = &quot;</span> &lt;&lt; SingletonTwo::GetInstance().b &lt;&lt; std::endl;
}
</pre></div><p> If SingletonTwo was destroyed before SingletonOne, this leads to the mentioned problems. Note that this problem only occurs for static objects defined in the same shared library.</p>
<p>Since you cannot reliably control the destruction order of global static objects, you must not introduce dependencies between them during static deinitialization. This is one reason why one should consider an alternative approach to singletons (unless you can absolutely make sure that nothing in your shared library will introduce such dependencies. Never.)</p>
<p>Of course you could use something like a "Phoenix singleton" but that will have other drawbacks in certain scenarios. Returning pointers instead of references in GetInstance() would open up the possibility to return NULL, but than again this would not help if you require a non-NULL instance in your destructor.</p>
<p>Another reason for an alternative approach is that singletons are usually not meant to be singletons for eternity. If your design evolves, you might hit a point where you suddenly need multiple instances of your singleton.</p>
<h2><a class="anchor" id="MicroServices_EmulateSingleton_2"></a>
Singletons as a service</h2>
<p>The C++ Micro Services can be used to emulate the singleton pattern using a non-singleton class. This leaves room for future extensions without the need for heavy refactoring. Additionally, it gives you full control about the construction and destruction order of your "singletons" inside your shared library or executable, making it possible to have dependencies between them during destruction.</p>
<h3><a class="anchor" id="MicroServices_EmulateSingleton_2_1"></a>
Converting a classic singleton</h3>
<p>We modify the previous SingletonOne class such that it internally uses the micro services API. The changes are discussed in detail below.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>SingletonOneService : <span class="keyword">public</span> US_BASECLASS_NAME
{
<span class="keyword">public</span>:

  <span class="comment">// This will return a SingletonOneService instance with the</span>
  <span class="comment">// lowest service id at the time this method was called the first</span>
  <span class="comment">// time and returned a non-null value (which is usually the instance</span>
  <span class="comment">// which was registered first). A null-pointer is returned if no</span>
  <span class="comment">// instance was registered yet.</span>
  <span class="keyword">static</span> SingletonOneService* GetInstance();

  <span class="keywordtype">int</span> a;

<span class="keyword">private</span>:

  <span class="comment">// Only our module activator class should be able to instantiate</span>
  <span class="comment">// a SingletonOneService object.</span>
  <span class="keyword">friend</span> <span class="keyword">class </span>MyActivator;

  SingletonOneService();
  ~SingletonOneService();

  <span class="comment">// Disable copy constructor and assignment operator.</span>
  SingletonOneService(<span class="keyword">const</span> SingletonOneService&amp;);
  SingletonOneService&amp; operator=(<span class="keyword">const</span> SingletonOneService&amp;);
};

US_DECLARE_SERVICE_INTERFACE(SingletonOneService, <span class="stringliteral">&quot;org.cppmicroservices.snippet.SingletonOneService&quot;</span>)
</pre></div><ul>
<li>Inherit itk::LightObject: All service implementations (not their interfaces) must inherit from itk::LightObject. In the implementation above, the class SingletonOneService provides the implementation as well as the interface.</li>
<li>Friend activator: We move the responsibility of constructing instances of SingletonOneService from the GetInstance() method to the module activator.</li>
<li>Service interface declaration: Because the SingletonOneService class introduces a new service interface, it must be registered under a unique name using the helper macro US_DECLARE_SERVICE_INTERFACE.</li>
</ul>
<p>Let's have a look at the modified GetInstance() and ~SingletonOneService() methods.</p>
<div class="fragment"><pre class="fragment">SingletonOneService* SingletonOneService::GetInstance()
{
  <span class="keyword">static</span> <a class="code" href="classServiceReference.html">ServiceReference</a> serviceRef;
  <span class="keyword">static</span> <a class="code" href="classModuleContext.html">ModuleContext</a>* context = GetModuleContext();

  <span class="keywordflow">if</span> (!serviceRef)
  {
    <span class="comment">// This is either the first time GetInstance() was called,</span>
    <span class="comment">// or a SingletonOneService instance has not yet been registered.</span>
    serviceRef = context-&gt;<a class="code" href="classModuleContext.html#ad4e3f72bad1067aba49283e851448253">GetServiceReference</a>&lt;SingletonOneService&gt;();
  }

  <span class="keywordflow">if</span> (serviceRef)
  {
    <span class="comment">// We have a valid service reference. It always points to the service</span>
    <span class="comment">// with the lowest id (usually the one which was registered first).</span>
    <span class="comment">// This still might return a null pointer, if all SingletonOneService</span>
    <span class="comment">// instances have been unregistered (during unloading of the library,</span>
    <span class="comment">// for example).</span>
    <span class="keywordflow">return</span> context-&gt;<a class="code" href="classModuleContext.html#a2bdfe2bcbae824b0cd6aa79bc4489850">GetService</a>&lt;SingletonOneService&gt;(serviceRef);
  }
  <span class="keywordflow">else</span>
  {
    <span class="comment">// No SingletonOneService instance was registered yet.</span>
    <span class="keywordflow">return</span> 0;
  }
}
</pre></div><p> The inline comments should explain the details. Note that we now had to change the return type to a pointer, instead of a reference as in the classic singleton. This is necessary since we can no longer guarantee that an instance always exists. Clients of the GetInstance() method must check for null pointers and react appropriately.</p>
<dl class="section warning"><dt>Warning:</dt><dd>Newly created "singletons" should not expose a GetInstance() method. They should be handled as proper services and hence should be retrieved by clients using the mitk::ModuleContext or mitk::ServiceTracker API. The GetInstance() method is for migration purposes only.</dd></dl>
<div class="fragment"><pre class="fragment">SingletonOneService::~SingletonOneService()
{
  SingletonTwoService* singletonTwoService = SingletonTwoService::GetInstance();

  <span class="comment">// The module activator must ensure that a SingletonTwoService instance is</span>
  <span class="comment">// available during destruction of a SingletonOneService instance.</span>
  assert(singletonTwoService != 0);
  std::cout &lt;&lt; <span class="stringliteral">&quot;SingletonTwoService::b = &quot;</span> &lt;&lt; singletonTwoService-&gt;b &lt;&lt; std::endl;
}
</pre></div><p> The SingletonTwoService::GetInstance() method is implemented exactly as in SingletonOneService. Because we know that the module activator guarantees that a SingletonTwoService instance will always be available during the life-time of a SingletonOneService instance (see below), we can assert a non-null pointer. Otherwise, we would have to handle the null-pointer case.</p>
<p>The order of construction/registration and destruction/unregistration of our singletons (or any other services) is defined in the Load() and Unload() methods of the module activator.</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> Load(<a class="code" href="classModuleContext.html">ModuleContext</a>* context)
  {
    <span class="comment">// The Load() method of the module activator is called during static</span>
    <span class="comment">// initialization time of the shared library.</span>

    <span class="comment">// First create and register a SingletonTwoService instance.</span>
    m_SingletonTwo = <span class="keyword">new</span> SingletonTwoService;
    m_SingletonTwoReg = context-&gt;<a class="code" href="classModuleContext.html#a7399fcc65ae1625cc06e4010e9e262d6">RegisterService</a>&lt;SingletonTwoService&gt;(m_SingletonTwo);

    <span class="comment">// Now the SingletonOneService constructor will get a valid</span>
    <span class="comment">// SingletonTwoService instance.</span>
    m_SingletonOne = <span class="keyword">new</span> SingletonOneService;
    m_SingletonOneReg = context-&gt;<a class="code" href="classModuleContext.html#a7399fcc65ae1625cc06e4010e9e262d6">RegisterService</a>&lt;SingletonOneService&gt;(m_SingletonOne);
  }
</pre></div><p> The Unload() method is defined as:</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> Unload(<a class="code" href="classModuleContext.html">ModuleContext</a>* <span class="comment">/*context*/</span>)
  {
    <span class="comment">// Services are automatically unregistered during unloading of</span>
    <span class="comment">// the shared library after the call to Unload(mitk::ModuleContext*)</span>
    <span class="comment">// has returned.</span>

    <span class="comment">// Since SingletonOneService needs a non-null SingletonTwoService</span>
    <span class="comment">// instance in its destructor, we explicitly unregister and delete the</span>
    <span class="comment">// SingletonOneService instance here. This way, the SingletonOneService</span>
    <span class="comment">// destructor will still get a valid SingletonTwoService instance.</span>
    m_SingletonOneReg.Unregister();
    <span class="keyword">delete</span> m_SingletonOne;

    <span class="comment">// For singletonTwoService, we could rely on the automatic unregistering</span>
    <span class="comment">// by the service registry and on automatic deletion if you used</span>
    <span class="comment">// smart pointer reference counting. You must not delete service instances</span>
    <span class="comment">// in this method without unregistering them first.</span>
    m_SingletonTwoReg.Unregister();
    <span class="keyword">delete</span> m_SingletonTwo;
  }
</pre></div></div></div><!-- contents -->


  <hr class="footer"/>
  <address class="footer"><small>Generated on Mon Apr 2 2012 10:12:39 for C++ Micro Services by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.0
  </small></address>

