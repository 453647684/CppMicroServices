---
layout: default
title: Service Hooks
---
  <head>
    <title>C++ Micro Services: Service Hooks</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
  </head>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="MicroServices_UserDocs.html">User Documentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Service Hooks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The CppMicroServices library implements the Service Hook Service Specification Version 1.1 from OSGi Core Release 5 for C++. Below is a summary of the concept - consult the OSGi specifications for more details.</p>
<p>Service hooks provide mechanisms for module writers to closely interact with the CppMicroServices service registry. These mechanisms are not intended for use by application modules but rather by modules in need of <em>hooking</em> into the service registry and modifying the behaviour of application modules.</p>
<p>Specific use case for service hooks include proxying of existing services by hiding the original service and registering a <em>proxy service</em> with the same properties or providing services <em>on demand</em> based on registered service listeners from external modules.</p>
<h2>Event Listener Hook</h2>
<p>A module can intercept events being delivered to other modules by registering a <a class="el" href="structServiceEventListenerHook.html" title="Service Event Listener Hook Service. ">ServiceEventListenerHook</a> object as a service. The CppMicroServices library will send all service events to all the registered hooks using the reversed ordering of their <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> objects. Note that event listener hooks are called <em>after</em> the event was created but <em>before</em> it is filtered by the optional filter expression of the service listeners. Hence an event listener hook receives all <a class="el" href="classServiceEvent.html#ae7426fe742bd938523b64d43c232a49fa658bb6e21586fc2d75ca841244199cd2">REGISTERED</a>, <a class="el" href="classServiceEvent.html#ae7426fe742bd938523b64d43c232a49fa25995ae997a4ee33c892e430a1fd2ca4">MODIFIED</a>, <a class="el" href="classServiceEvent.html#ae7426fe742bd938523b64d43c232a49fa2727d97ff0e689285e6364afe42ecf81">UNREGISTERING</a>, and <a class="el" href="classServiceEvent.html#ae7426fe742bd938523b64d43c232a49fab484788a8da6e1d61d07e6014044c6fc">MODIFIED_ENDMATCH</a> events regardelss of the presence of a service listener filter. It may then remove modules or specific service listeners from the <a class="el" href="structServiceEventListenerHook.html#a2f013c791e43f2e62f658c02af56ddcb">ServiceEventListenerHook::ShrinkableMapType</a> object passed to the <a class="el" href="structServiceEventListenerHook.html#afaeb4090c9e68459805ba11af3ed9f0e" title="Event listener hook method. ">ServiceEventListenerHook::Event</a> method to hide service events.</p>
<p>Implementers of the Event Listener Hook must ensure that modules continue to see a consistent set of service events.</p>
<h2>Find Hook</h2>
<p>Find Hook objects registered using the <a class="el" href="structServiceFindHook.html" title="Service Find Hook Service. ">ServiceFindHook</a> interface will be called when modules look up service references via the <a class="el" href="classModuleContext.html#af47528f02bd276ba9b738b17f60d04f8" title="Returns a ServiceReference object for a service that implements and was registered under the specifie...">ModuleContext::GetServiceReference</a> or <a class="el" href="classModuleContext.html#a8b1be96ec5dcf6452d5e3f236c9fd20a" title="Returns a list of ServiceReference objects. ">ModuleContext::GetServiceReferences</a> methods. The order in which the CppMicroServices library calls the find hooks is the reverse <code>operator&lt;</code> ordering of their <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> objects. The hooks may remove service references from the <a class="el" href="classShrinkableVector.html" title="A std::vector style container allowing query and removal operations only. ">ShrinkableVector</a> object passed to the <a class="el" href="structServiceFindHook.html#a24db0dcbc2dc6e6a2e6319f0a5372869" title="Find hook method. ">ServiceFindHook::Find</a> method to hide services from specific modules.</p>
<h2>Listener Hook</h2>
<p>The CppMicroServices API provides information about the registration, unregistration, and modification of services. However, it does not directly allow the introspection of modules to get information about what services a module is waiting for. Waiting for a service to arrive (via a registered service listener) before performing its function is a common pattern for modules. Listener Hooks provide a mechanism to get informed about all existing, newly registerd, and removed service listeners.</p>
<p>A Listener Hook object registered using the <a class="el" href="structServiceListenerHook.html" title="Service Listener Hook Service. ">ServiceListenerHook</a> interface will be notified about service listeners by being passed <a class="el" href="structServiceListenerHook_1_1ListenerInfo.html" title="Information about a Service Listener. ">ServiceListenerHook::ListenerInfo</a> objects. Each ListenerInfo object is related to the registration / unregistration cycle of a specific service listener. That is, registering the same service listener again, even with a different filter, will automatically unregister the previouse registration and the newly registered service listener is related to a different ListenerInfo object. ListenerInfo objects can be stored in unordered containers and compared with each other, e.g. to match <a class="el" href="structServiceListenerHook.html#ada497a9595e6c22e84eb821784b4ce79" title="Added listeners hook method. ">ServiceListenerHook::Added</a> and <a class="el" href="structServiceListenerHook.html#a63ef53442bf35de50790e0c628d57077" title="Removed listeners hook method. ">ServiceListenerHook::Removed</a> calls.</p>
<p>The Listener Hooks are called synchronously in the same order of their registration. However, in rare cases the removal of a service listener may be reported before its corresponding addition. To handle this case, the ListenerInfo::IsRemoved() method is provided which can be used in the <a class="el" href="structServiceListenerHook.html#ada497a9595e6c22e84eb821784b4ce79" title="Added listeners hook method. ">ServiceListenerHook::Added</a> method to detect the out of order delivery. A simple strategy is to ignore removed events without corresponding added events and ignore added events where the ListenerInfo object is already removed:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyServiceListenerHook : <span class="keyword">public</span> <a class="code" href="structServiceListenerHook.html">ServiceListenerHook</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"></div>
<div class="line">  <span class="keyword">class </span>Tracked</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Do some work during construction and destruction</span></div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  US_UNORDERED_MAP_TYPE&lt;ListenerInfo, Tracked&gt; tracked;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structServiceListenerHook.html#ada497a9595e6c22e84eb821784b4ce79">Added</a>(<span class="keyword">const</span> std::vector&lt;ListenerInfo&gt;&amp; listeners)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (std::vector&lt;ListenerInfo&gt;::const_iterator iter = listeners.begin(),</div>
<div class="line">         endIter = listeners.end(); iter != endIter; ++iter)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Lock the tracked object for thread-safe access</span></div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (iter-&gt;IsRemoved()) <span class="keywordflow">return</span>;</div>
<div class="line">      tracked.insert(std::make_pair(*iter, Tracked()));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structServiceListenerHook.html#a63ef53442bf35de50790e0c628d57077">Removed</a>(<span class="keyword">const</span> std::vector&lt;ListenerInfo&gt;&amp; listeners)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (std::vector&lt;ListenerInfo&gt;::const_iterator iter = listeners.begin(),</div>
<div class="line">         endIter = listeners.end(); iter != endIter; ++iter)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Lock the tracked object for thread-safe access</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// If we got a corresponding &quot;Added&quot; event before, the Tracked</span></div>
<div class="line">      <span class="comment">// destructor will do some cleanup...</span></div>
<div class="line">      tracked.erase(*iter);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> <h2>Architectural Notes</h2>
<h3>Ordinary Services</h3>
<p>All service hooks are treated as ordinary services. If the CppMicroServices library uses them, their Service References will show that the CppMicroServices modules is using them, and if a hook is a Service Factory, then the actual instance will be properly created.</p>
<p>The only speciality of the service hooks is that the CppMicroServices library does not use them for the hooks themselves. That is, the Service Event and Service Find Hooks can not be used to hide the services from the CppMicroServices library.</p>
<h3>Ordering</h3>
<p>The hooks are very sensitive to ordering because they interact directly with the service registry. In general, implementers of the hooks must be aware that other modules can be loaded before or after the module which provides the hooks. To ensure early registration of the hooks, they should be registered within the <a class="el" href="structModuleActivator.html#a1db3f85c15a814a5918eb22725229967" title="Called when this module is loaded. ">ModuleActivator::Load</a> method of the program executable or a module being auto-loaded with the executable.</p>
<h3>Multi Threading</h3>
<p>All hooks must be thread-safe because the hooks can be called at any time. All hook methods must be re-entrant, they can be entered at any time and in rare cases in the wrong order. The CppMicroServices library calls all hook methods synchronously but the calls might be triggered from any user thread interacting with the CppMicroServices API. The CppMicroServices API can be called from any of the hook methods but implementers must be careful to not hold any lock while calling CppMicroServices methods. </p>
</div></div><!-- contents -->

  <hr class="footer"/>
  <address class="footer"><small>Generated on Wed Oct 1 2014 for C++ Micro Services 2.99.0 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.6
</small></address>
