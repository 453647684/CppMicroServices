---
layout: default
title: Module Class Reference
---
  <head>
    <title>C++ Micro Services: Module Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
  </head>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classModule-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Module Class Reference<div class="ingroups"><a class="el" href="group__MicroServices.html">Micro Services Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a CppMicroServices module.  
 <a href="classModule.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Module:</div>
<div class="dyncontent">
<div class="center"><img src="classModule__inherit__graph.png" border="0" usemap="#Module_inherit__map" alt="Inheritance graph"/></div>
<map name="Module_inherit__map" id="Module_inherit__map">
<area shape="rect" id="node2" href="classFramework.html" title="The CppMicroServices Framework. " alt="" coords="5,80,92,107"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94522964ee481ea69fc79e633dce293e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a94522964ee481ea69fc79e633dce293e">Module</a> (const <a class="el" href="classModule.html">Module</a> &amp;)=delete</td></tr>
<tr class="separator:a94522964ee481ea69fc79e633dce293e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafec8c8c502460b1f7e4aaadcb9ab1b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModule.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#aafec8c8c502460b1f7e4aaadcb9ab1b7">operator=</a> (const <a class="el" href="classModule.html">Module</a> &amp;)=delete</td></tr>
<tr class="separator:aafec8c8c502460b1f7e4aaadcb9ab1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f2a54e7dacfb7a67355f1412c07130"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a57f2a54e7dacfb7a67355f1412c07130">~Module</a> ()</td></tr>
<tr class="separator:a57f2a54e7dacfb7a67355f1412c07130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb822aabcaa58664e4802d736542d9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a6eb822aabcaa58664e4802d736542d9b">IsLoaded</a> () const </td></tr>
<tr class="memdesc:a6eb822aabcaa58664e4802d736542d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's current state.  <a href="#a6eb822aabcaa58664e4802d736542d9b">More...</a><br /></td></tr>
<tr class="separator:a6eb822aabcaa58664e4802d736542d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c027deb575198ba11a37cca2f2faf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModuleContext.html">ModuleContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a66c027deb575198ba11a37cca2f2faf7">GetModuleContext</a> () const </td></tr>
<tr class="memdesc:a66c027deb575198ba11a37cca2f2faf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's <a class="el" href="classModuleContext.html">ModuleContext</a>.  <a href="#a66c027deb575198ba11a37cca2f2faf7">More...</a><br /></td></tr>
<tr class="separator:a66c027deb575198ba11a37cca2f2faf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179725f9aecd04cf59f0a8e74cdf05a4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a179725f9aecd04cf59f0a8e74cdf05a4">GetModuleId</a> () const </td></tr>
<tr class="memdesc:a179725f9aecd04cf59f0a8e74cdf05a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's unique identifier.  <a href="#a179725f9aecd04cf59f0a8e74cdf05a4">More...</a><br /></td></tr>
<tr class="separator:a179725f9aecd04cf59f0a8e74cdf05a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c7c74e28b483b20b1e69c003a84d36"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a85c7c74e28b483b20b1e69c003a84d36">GetLocation</a> () const </td></tr>
<tr class="memdesc:a85c7c74e28b483b20b1e69c003a84d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's location.  <a href="#a85c7c74e28b483b20b1e69c003a84d36">More...</a><br /></td></tr>
<tr class="separator:a85c7c74e28b483b20b1e69c003a84d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71880e4be55811df7aeab43a5c9046b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a71880e4be55811df7aeab43a5c9046b4">GetName</a> () const </td></tr>
<tr class="memdesc:a71880e4be55811df7aeab43a5c9046b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this module as specified by the US_CREATE_MODULE CMake macro.  <a href="#a71880e4be55811df7aeab43a5c9046b4">More...</a><br /></td></tr>
<tr class="separator:a71880e4be55811df7aeab43a5c9046b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c96bbe3653bec5a8ed5d1b56d6cddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModuleVersion.html">ModuleVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a20c96bbe3653bec5a8ed5d1b56d6cddf">GetVersion</a> () const </td></tr>
<tr class="memdesc:a20c96bbe3653bec5a8ed5d1b56d6cddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version of this module as specified by the US_INITIALIZE_MODULE CMake macro.  <a href="#a20c96bbe3653bec5a8ed5d1b56d6cddf">More...</a><br /></td></tr>
<tr class="separator:a20c96bbe3653bec5a8ed5d1b56d6cddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa885cfb92466c142e1903bb6fab638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAny.html">Any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a3fa885cfb92466c142e1903bb6fab638">GetProperty</a> (const std::string &amp;key) const </td></tr>
<tr class="memdesc:a3fa885cfb92466c142e1903bb6fab638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the specified property for this module.  <a href="#a3fa885cfb92466c142e1903bb6fab638">More...</a><br /></td></tr>
<tr class="separator:a3fa885cfb92466c142e1903bb6fab638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0417ce52b2b1dedfe513a66cb3cb432c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a0417ce52b2b1dedfe513a66cb3cb432c">GetPropertyKeys</a> () const </td></tr>
<tr class="memdesc:a0417ce52b2b1dedfe513a66cb3cb432c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of top-level property keys for this module.  <a href="#a0417ce52b2b1dedfe513a66cb3cb432c">More...</a><br /></td></tr>
<tr class="separator:a0417ce52b2b1dedfe513a66cb3cb432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab1e28d22d60b049c515d4256363b44"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classServiceReference.html">ServiceReferenceU</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a8ab1e28d22d60b049c515d4256363b44">GetRegisteredServices</a> () const </td></tr>
<tr class="memdesc:a8ab1e28d22d60b049c515d4256363b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it has registered or an empty list if this module has no registered services.  <a href="#a8ab1e28d22d60b049c515d4256363b44">More...</a><br /></td></tr>
<tr class="separator:a8ab1e28d22d60b049c515d4256363b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6934e75db2be837723fb6e21125bca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classServiceReference.html">ServiceReferenceU</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#adf6934e75db2be837723fb6e21125bca">GetServicesInUse</a> () const </td></tr>
<tr class="memdesc:adf6934e75db2be837723fb6e21125bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it is using or returns an empty list if this module is not using any services.  <a href="#adf6934e75db2be837723fb6e21125bca">More...</a><br /></td></tr>
<tr class="separator:adf6934e75db2be837723fb6e21125bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663b9033cb569becb414ca4d9064622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModuleResource.html">ModuleResource</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ae663b9033cb569becb414ca4d9064622">GetResource</a> (const std::string &amp;path) const </td></tr>
<tr class="memdesc:ae663b9033cb569becb414ca4d9064622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resource at the specified <code>path</code> in this module.  <a href="#ae663b9033cb569becb414ca4d9064622">More...</a><br /></td></tr>
<tr class="separator:ae663b9033cb569becb414ca4d9064622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9766f0366ddd2ac0b838f17d1e262e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classModuleResource.html">ModuleResource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a1b9766f0366ddd2ac0b838f17d1e262e">FindResources</a> (const std::string &amp;path, const std::string &amp;filePattern, bool recurse) const </td></tr>
<tr class="memdesc:a1b9766f0366ddd2ac0b838f17d1e262e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resources in this module.  <a href="#a1b9766f0366ddd2ac0b838f17d1e262e">More...</a><br /></td></tr>
<tr class="separator:a1b9766f0366ddd2ac0b838f17d1e262e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9229993dada6ed800f73036aade722"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#aed9229993dada6ed800f73036aade722">Start</a> ()</td></tr>
<tr class="memdesc:aed9229993dada6ed800f73036aade722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start this bundle.  <a href="#aed9229993dada6ed800f73036aade722">More...</a><br /></td></tr>
<tr class="separator:aed9229993dada6ed800f73036aade722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e46c36f5eacfdb7dcd95e0548c5e8e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a3e46c36f5eacfdb7dcd95e0548c5e8e3">Stop</a> ()</td></tr>
<tr class="memdesc:a3e46c36f5eacfdb7dcd95e0548c5e8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop this bundle.  <a href="#a3e46c36f5eacfdb7dcd95e0548c5e8e3">More...</a><br /></td></tr>
<tr class="separator:a3e46c36f5eacfdb7dcd95e0548c5e8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82b41a2971bfa51f0b5a501624a7b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a0f82b41a2971bfa51f0b5a501624a7b2">Uninstall</a> ()</td></tr>
<tr class="memdesc:a0f82b41a2971bfa51f0b5a501624a7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstalls this bundle.  <a href="#a0f82b41a2971bfa51f0b5a501624a7b2">More...</a><br /></td></tr>
<tr class="separator:a0f82b41a2971bfa51f0b5a501624a7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad6bd8ff9e1efe6f883d939481a030fbc"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ad6bd8ff9e1efe6f883d939481a030fbc">PROP_ID</a> ()</td></tr>
<tr class="memdesc:ad6bd8ff9e1efe6f883d939481a030fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key for looking up this module's id.  <a href="#ad6bd8ff9e1efe6f883d939481a030fbc">More...</a><br /></td></tr>
<tr class="separator:ad6bd8ff9e1efe6f883d939481a030fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab605045d336e05ee0c8a7925fbe3234b"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ab605045d336e05ee0c8a7925fbe3234b">PROP_NAME</a> ()</td></tr>
<tr class="memdesc:ab605045d336e05ee0c8a7925fbe3234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key for looking up this module's name.  <a href="#ab605045d336e05ee0c8a7925fbe3234b">More...</a><br /></td></tr>
<tr class="separator:ab605045d336e05ee0c8a7925fbe3234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e41a7671443f5e0ff345950b9949b81"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a0e41a7671443f5e0ff345950b9949b81">PROP_LOCATION</a> ()</td></tr>
<tr class="memdesc:a0e41a7671443f5e0ff345950b9949b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key for looking up this module's location in the file system.  <a href="#a0e41a7671443f5e0ff345950b9949b81">More...</a><br /></td></tr>
<tr class="separator:a0e41a7671443f5e0ff345950b9949b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad616f286d832d168958541f316e2a81"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#aad616f286d832d168958541f316e2a81">PROP_VERSION</a> ()</td></tr>
<tr class="memdesc:aad616f286d832d168958541f316e2a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.version</code> for looking up this module's version identifier.  <a href="#aad616f286d832d168958541f316e2a81">More...</a><br /></td></tr>
<tr class="separator:aad616f286d832d168958541f316e2a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf1aac88e946fff1ae72895698496ce"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#abdf1aac88e946fff1ae72895698496ce">PROP_VENDOR</a> ()</td></tr>
<tr class="memdesc:abdf1aac88e946fff1ae72895698496ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.vendor</code> for looking up this module's vendor information.  <a href="#abdf1aac88e946fff1ae72895698496ce">More...</a><br /></td></tr>
<tr class="separator:abdf1aac88e946fff1ae72895698496ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036bca9543c13741b0eee9656550041c"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a036bca9543c13741b0eee9656550041c">PROP_DESCRIPTION</a> ()</td></tr>
<tr class="memdesc:a036bca9543c13741b0eee9656550041c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.description</code> for looking up this module's description.  <a href="#a036bca9543c13741b0eee9656550041c">More...</a><br /></td></tr>
<tr class="separator:a036bca9543c13741b0eee9656550041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9986bc0261acc8b4a8321c561215a69"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#ae9986bc0261acc8b4a8321c561215a69">PROP_AUTOLOAD_DIR</a> ()</td></tr>
<tr class="memdesc:ae9986bc0261acc8b4a8321c561215a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.autoload_dir</code> for looking up this module's auto-load directory.  <a href="#ae9986bc0261acc8b4a8321c561215a69">More...</a><br /></td></tr>
<tr class="separator:ae9986bc0261acc8b4a8321c561215a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536db5f209276917b8e02ca310dc1f34"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModule.html#a536db5f209276917b8e02ca310dc1f34">PROP_AUTOLOADED_MODULES</a> ()</td></tr>
<tr class="memdesc:a536db5f209276917b8e02ca310dc1f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property key with a value of <code>module.autoloaded_modules</code> for looking up this module's auto-load modules.  <a href="#a536db5f209276917b8e02ca310dc1f34">More...</a><br /></td></tr>
<tr class="separator:a536db5f209276917b8e02ca310dc1f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a CppMicroServices module. </p>
<p>A <code>Module</code> object is the access point to a CppMicroServices module. Each CppMicroServices module has an associated <code>Module</code> object.</p>
<p>A module has unique identity, a <code>long</code>, chosen by the framework. This identity does not change during the lifecycle of a module.</p>
<p>A module can be in one of four states: </p><ul>
<li>
INSTALLED </li>
<li>
LOADED </li>
<li>
UNLOADED </li>
<li>
UNINSTALLED </li>
</ul>
<p>You can determine whether a bundle is loaded or not by using <a class="el" href="classModule.html#a6eb822aabcaa58664e4802d736542d9b" title="Returns this module&#39;s current state. ">IsLoaded()</a>.</p>
<p>A module can only execute code when its state is <code>LOADED</code>. An <code>UNLOADED</code> module is a zombie and can only be reached because it was loaded before. However, unloaded modules can be loaded again.</p>
<p>The framework is the only entity that is allowed to create <code>Module</code> objects.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This class is thread safe. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a94522964ee481ea69fc79e633dce293e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Module::Module </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModule.html">Module</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a57f2a54e7dacfb7a67355f1412c07130"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Module::~Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b9766f0366ddd2ac0b838f17d1e262e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classModuleResource.html">ModuleResource</a>&gt; Module::FindResources </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns resources in this module. </p>
<p>This method is intended to be used to obtain configuration, setup, localization and other information from this module.</p>
<p>This method can either return only resources in the specified <code>path</code> or recurse into subdirectories returning resources in the directory tree beginning at the specified path.</p>
<p>Examples: </p><div class="fragment"><div class="line">  <a class="code" href="classModuleContext.html">ModuleContext</a>* moduleContext = <a class="code" href="classModule.html#a66c027deb575198ba11a37cca2f2faf7">GetModuleContext</a>();</div>
<div class="line">  <a class="code" href="classModule.html">Module</a>* module = moduleContext-&gt;<a class="code" href="classModuleContext.html#ae4fc39476ca5a30e0cbe5af26de4b4e3">GetModule</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// List all XML files in the config directory</span></div>
<div class="line">  std::vector&lt;ModuleResource&gt; xmlFiles = module-&gt;<a class="code" href="classModule.html#a1b9766f0366ddd2ac0b838f17d1e262e">FindResources</a>(<span class="stringliteral">&quot;config&quot;</span>, <span class="stringliteral">&quot;*.xml&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Find the resource named vertex_shader.txt starting at the root directory</span></div>
<div class="line">  std::vector&lt;ModuleResource&gt; shaders = module-&gt;<a class="code" href="classModule.html#a1b9766f0366ddd2ac0b838f17d1e262e">FindResources</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;vertex_shader.txt&quot;</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path name in which to look. The path is always relative to the root of this module and may begin with '/'. A path value of "/" indicates the root of this module. </td></tr>
    <tr><td class="paramname">filePattern</td><td>The resource name pattern for selecting entries in the specified path. The pattern is only matched against the last element of the resource path. Substring matching is supported using the wildcard charachter ('*'). If <code>filePattern</code> is empty, this is equivalent to "*" and matches all resources. </td></tr>
    <tr><td class="paramname">recurse</td><td>If <code>true</code>, recurse into subdirectories. Otherwise only return resources from the specified path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> objects for each matching entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a85c7c74e28b483b20b1e69c003a84d36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Module::GetLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this module's location. </p>
<p>The location is the full path to the module's shared library. This method continues to return this module's location while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The string representation of this module's location. </dd></dl>

<p>Reimplemented in <a class="el" href="classFramework.html#a1d3863b35f6a03c37a11698ffd0ae972">Framework</a>.</p>

</div>
</div>
<a class="anchor" id="a66c027deb575198ba11a37cca2f2faf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModuleContext.html">ModuleContext</a>* Module::GetModuleContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's <a class="el" href="classModuleContext.html">ModuleContext</a>. </p>
<p>The returned <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code> can be used by the caller to act on behalf of this module.</p>
<p>If this module is not in the <code>LOADED</code> state, then this module has no valid <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code>. This method will return <code>0</code> if this module has no valid <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code> for this module or <code>0</code> if this module has no valid <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework. ">ModuleContext</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a179725f9aecd04cf59f0a8e74cdf05a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Module::GetModuleId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's unique identifier. </p>
<p>This module is assigned a unique identifier by the framework when it was loaded.</p>
<p>A module's unique identifier has the following attributes: </p><ul>
<li>
Is unique. </li>
<li>
Is a <code>long</code>. </li>
<li>
Its value is not reused for another module, even after a module is unloaded. </li>
<li>
Does not change while a module remains loaded. </li>
<li>
Does not change when a module is reloaded. </li>
</ul>
<p>This method continues to return this module's unique identifier while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The unique identifier of this module. </dd></dl>

</div>
</div>
<a class="anchor" id="a71880e4be55811df7aeab43a5c9046b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Module::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of this module as specified by the US_CREATE_MODULE CMake macro. </p>
<p>The module name together with a version must identify a unique module.</p>
<p>This method continues to return this module's name while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of this module. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fa885cfb92466c142e1903bb6fab638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAny.html">Any</a> Module::GetProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the specified property for this module. </p>
<p>If not found, the framework's properties are searched. The method returns an empty <a class="el" href="classAny.html" title="An Any class represents a general type and is capable of storing any type, supporting type-safe extra...">Any</a> if the property is not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name of the requested property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the requested property, or an empty string if the property is undefined.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classModule.html#a0417ce52b2b1dedfe513a66cb3cb432c" title="Returns a list of top-level property keys for this module. ">GetPropertyKeys()</a> </dd>
<dd>
<a class="el" href="MicroServices_ModuleProperties.html">Module Properties</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0417ce52b2b1dedfe513a66cb3cb432c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Module::GetPropertyKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of top-level property keys for this module. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of available property keys.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="MicroServices_ModuleProperties.html">Module Properties</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab1e28d22d60b049c515d4256363b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classServiceReference.html">ServiceReferenceU</a>&gt; Module::GetRegisteredServices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it has registered or an empty list if this module has no registered services. </p>
<p>The list is valid at the time of the call to this method, however, as the framework is a very dynamic environment, services can be modified or unregistered at anytime.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> objects for services this module has registered. </dd></dl>

</div>
</div>
<a class="anchor" id="ae663b9033cb569becb414ca4d9064622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModuleResource.html">ModuleResource</a> Module::GetResource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the resource at the specified <code>path</code> in this module. </p>
<p>The specified <code>path</code> is always relative to the root of this module and may begin with '/'. A path value of "/" indicates the root of this module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path name of the resource. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> object for the given <code>path</code>. If the <code>path</code> cannot be found in this module or the module's state is <code>UNLOADED</code>, an invalid <a class="el" href="classModuleResource.html" title="Represents a resource (text file, image, etc.) embedded in a CppMicroServices module. ">ModuleResource</a> object is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="adf6934e75db2be837723fb6e21125bca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classServiceReference.html">ServiceReferenceU</a>&gt; Module::GetServicesInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> list for all services it is using or returns an empty list if this module is not using any services. </p>
<p>A module is considered to be using a service if its use count for that service is greater than zero.</p>
<p>The list is valid at the time of the call to this method, however, as the framework is a very dynamic environment, services can be modified or unregistered at anytime.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of <a class="el" href="classServiceReference.html" title="A reference to a service. ">ServiceReference</a> objects for all services this module is using. </dd></dl>

</div>
</div>
<a class="anchor" id="a20c96bbe3653bec5a8ed5d1b56d6cddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModuleVersion.html">ModuleVersion</a> Module::GetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the version of this module as specified by the US_INITIALIZE_MODULE CMake macro. </p>
<p>If this module does not have a specified version then <a class="el" href="classModuleVersion.html#a75ea56c0729937b39345301674b434a2">ModuleVersion::EmptyVersion</a> is returned.</p>
<p>This method continues to return this module's version while this module is in the <code>UNLOADED</code> state.</p>
<dl class="section return"><dt>Returns</dt><dd>The version of this module. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb822aabcaa58664e4802d736542d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Module::IsLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns this module's current state. </p>
<p>A module can be in only one state at any time.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the module is <code>LOADED</code> <code>false</code> if it is in any other state. </dd></dl>

</div>
</div>
<a class="anchor" id="aafec8c8c502460b1f7e4aaadcb9ab1b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModule.html">Module</a>&amp; Module::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModule.html">Module</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9986bc0261acc8b4a8321c561215a69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_AUTOLOAD_DIR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.autoload_dir</code> for looking up this module's auto-load directory. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The auto-load directory property key. </dd></dl>

</div>
</div>
<a class="anchor" id="a536db5f209276917b8e02ca310dc1f34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_AUTOLOADED_MODULES </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.autoloaded_modules</code> for looking up this module's auto-load modules. </p>
<p>The property value is of type <code>std::vector&lt;std::string&gt;</code> and contains the file system locations for the auto-loaded modules triggered by this module.</p>
<dl class="section return"><dt>Returns</dt><dd>The auto-loaded modules property key. </dd></dl>

</div>
</div>
<a class="anchor" id="a036bca9543c13741b0eee9656550041c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_DESCRIPTION </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.description</code> for looking up this module's description. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The description property key. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6bd8ff9e1efe6f883d939481a030fbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_ID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key for looking up this module's id. </p>
<p>The property value is of type <code>long</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The id property key. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e41a7671443f5e0ff345950b9949b81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_LOCATION </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key for looking up this module's location in the file system. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The location property key. </dd></dl>

</div>
</div>
<a class="anchor" id="ab605045d336e05ee0c8a7925fbe3234b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_NAME </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key for looking up this module's name. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The name property key. </dd></dl>

</div>
</div>
<a class="anchor" id="abdf1aac88e946fff1ae72895698496ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_VENDOR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.vendor</code> for looking up this module's vendor information. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The vendor property key. </dd></dl>

</div>
</div>
<a class="anchor" id="aad616f286d832d168958541f316e2a81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Module::PROP_VERSION </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the property key with a value of <code>module.version</code> for looking up this module's version identifier. </p>
<p>The property value is of type <code>std::string</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The version property key. </dd></dl>

</div>
</div>
<a class="anchor" id="aed9229993dada6ed800f73036aade722"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Module::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start this bundle. </p>
<p>The following steps are required to start this bundle:</p><ol type="1">
<li>If this bundle is in the process of being activated or deactivated then this method must wait for activation or deactivation to complete before continuing. If this does not occur in a reasonable time, a std::runtime_error exception is thrown to indicate this bundle was unable to be started.</li>
<li>If this bundle was already started, then this method returns immediately.</li>
<li>A bundle event of type BundleEvent::STARTING is fired.</li>
<li>The BundleActivator::Start(BundleContext) method of this bundle's BundleActivator, if one is specified, is called. If the BundleActivator is invalid or throws an exception then:<ul>
<li>A bundle event of type BundleEvent::STOPPING is fired.</li>
<li>Any services registered by this bundle must be unregistered.</li>
<li>Any services used by this bundle must be released.</li>
<li>Any listeners registered by this bundle must be removed.</li>
<li>A bundle event of type BundleEvent::STOPPED is fired.</li>
<li>A std::runtime_error exception is then thrown.</li>
</ul>
</li>
<li>A bundle event of type BundleEvent::STARTED is fired.</li>
</ol>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If this bundle could not be started. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classFramework.html#aee500e180cf474b6883a5e3f7396912d">Framework</a>.</p>

</div>
</div>
<a class="anchor" id="a3e46c36f5eacfdb7dcd95e0548c5e8e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Module::Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop this bundle. </p>
<p>The following steps are required to stop a bundle:</p><ol type="1">
<li>If this bundle is in the process of being activated or deactivated then this method must wait for activation or deactivation to complete before continuing. If this does not occur in a reasonable time, a std::runtime_error exception is thrown to indicate this bundle was unable to be stopped.</li>
<li>If this bundle was already stopped, then this method returns immediately.</li>
<li>A bundle event of type BundleEvent::STOPPING is fired.</li>
<li>The BundleActivator::Stop(BundleContext) method of this bundle's BundleActivator, if one is specified, is called. If that method throws an exception, this method must continue to stop this bundle and a std::runtime_error exception must be thrown after completion of the remaining steps.</li>
<li>Any services registered by this bundle must be unregistered.</li>
<li>Any services used by this bundle must be released.</li>
<li>Any listeners registered by this bundle must be removed.</li>
<li>A bundle event of type BundleEvent::STOPPED is fired.</li>
</ol>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the bundle failed to stop. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classFramework.html#a15d9d9343fb2b5a21849a4633ca8dfc3">Framework</a>.</p>

</div>
</div>
<a class="anchor" id="a0f82b41a2971bfa51f0b5a501624a7b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Module::Uninstall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uninstalls this bundle. </p>
<p>This method causes the <a class="el" href="classFramework.html" title="The CppMicroServices Framework. ">Framework</a> to notify other bundles that this bundle is being uninstalled, and then uninstalls this bundle. The <a class="el" href="classFramework.html" title="The CppMicroServices Framework. ">Framework</a> must remove any resources related to this bundle that it is able to remove.</p>
<p>The following steps are required to uninstall a bundle:</p><ol type="1">
<li>This bundle is stopped as described in the Bundle.Stop method.</li>
<li>A bundle event of BundleEvent::UNINSTALLED is fired.</li>
<li>This bundle and any persistent storage area provided for this bundle by the <a class="el" href="classFramework.html" title="The CppMicroServices Framework. ">Framework</a> are removed.</li>
</ol>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the bundle could not be uninstalled. * </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classFramework.html#a43725f5c53658c0eacc3698ae0f6059a">Framework</a>.</p>

</div>
</div>
</div><!-- contents -->

  <hr class="footer"/>
  <address class="footer"><small>Generated on Tue Oct 6 2015 for C++ Micro Services 2.99.0 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.9.1
</small></address>
