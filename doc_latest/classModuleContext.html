---
layout: default
title: ModuleContext Class Reference
---
  <head>
    <title>C++ Micro Services: ModuleContext Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
  </head>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classModuleContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ModuleContext Class Reference<div class="ingroups"><a class="el" href="group__MicroServices.html">Micro Services Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A module's execution context within the framework.  
 <a href="classModuleContext.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51b9f169eeb6742a4d909ba7a3421730"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a51b9f169eeb6742a4d909ba7a3421730">~ModuleContext</a> ()</td></tr>
<tr class="separator:a51b9f169eeb6742a4d909ba7a3421730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fc39476ca5a30e0cbe5af26de4b4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModule.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ae4fc39476ca5a30e0cbe5af26de4b4e3">GetModule</a> () const </td></tr>
<tr class="memdesc:ae4fc39476ca5a30e0cbe5af26de4b4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with this <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code>.  <a href="#ae4fc39476ca5a30e0cbe5af26de4b4e3">More...</a><br/></td></tr>
<tr class="separator:ae4fc39476ca5a30e0cbe5af26de4b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d5bba1c8dff99e35ccef45fb0068d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModule.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a26d5bba1c8dff99e35ccef45fb0068d3">GetModule</a> (long id) const </td></tr>
<tr class="memdesc:a26d5bba1c8dff99e35ccef45fb0068d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the module with the specified identifier.  <a href="#a26d5bba1c8dff99e35ccef45fb0068d3">More...</a><br/></td></tr>
<tr class="separator:a26d5bba1c8dff99e35ccef45fb0068d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacffe98b55d1c01aeee0c0c69dd70ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#afacffe98b55d1c01aeee0c0c69dd70ee">GetModules</a> (std::vector&lt; <a class="el" href="classModule.html">Module</a> * &gt; &amp;modules) const </td></tr>
<tr class="memdesc:afacffe98b55d1c01aeee0c0c69dd70ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all known modules.  <a href="#afacffe98b55d1c01aeee0c0c69dd70ee">More...</a><br/></td></tr>
<tr class="separator:afacffe98b55d1c01aeee0c0c69dd70ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68596c589b57246927067742517ce47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MicroServices.html#ga7be3a427a87d460600d4aa9f36a039e4">ServiceRegistrationU</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47">RegisterService</a> (const <a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a> &amp;service, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:aa68596c589b57246927067742517ce47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties under the specified class names into the framework.  <a href="#aa68596c589b57246927067742517ce47">More...</a><br/></td></tr>
<tr class="separator:aa68596c589b57246927067742517ce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013068749e6a54ad7aaa73ec691fa3e5"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a013068749e6a54ad7aaa73ec691fa3e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a013068749e6a54ad7aaa73ec691fa3e5">RegisterService</a> (S *service, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a013068749e6a54ad7aaa73ec691fa3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties using the specified template argument with the framework.  <a href="#a013068749e6a54ad7aaa73ec691fa3e5">More...</a><br/></td></tr>
<tr class="separator:a013068749e6a54ad7aaa73ec691fa3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6d9800318464a9896ffb7c61a1fb34"><td class="memTemplParams" colspan="2">template&lt;class I1 , class I2 , class Impl &gt; </td></tr>
<tr class="memitem:a9b6d9800318464a9896ffb7c61a1fb34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a9b6d9800318464a9896ffb7c61a1fb34">RegisterService</a> (Impl *impl, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a9b6d9800318464a9896ffb7c61a1fb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties using the specified template argument with the framework.  <a href="#a9b6d9800318464a9896ffb7c61a1fb34">More...</a><br/></td></tr>
<tr class="separator:a9b6d9800318464a9896ffb7c61a1fb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ef7a4df92f91a62c50df4ca9100c70"><td class="memTemplParams" colspan="2">template&lt;class I1 , class I2 , class I3 , class Impl &gt; </td></tr>
<tr class="memitem:a76ef7a4df92f91a62c50df4ca9100c70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt; I1, I2, I3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a76ef7a4df92f91a62c50df4ca9100c70">RegisterService</a> (Impl *impl, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a76ef7a4df92f91a62c50df4ca9100c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties using the specified template argument with the framework.  <a href="#a76ef7a4df92f91a62c50df4ca9100c70">More...</a><br/></td></tr>
<tr class="separator:a76ef7a4df92f91a62c50df4ca9100c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2b7d86b1eab471f61270a0139edbcd"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:abf2b7d86b1eab471f61270a0139edbcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#abf2b7d86b1eab471f61270a0139edbcd">RegisterService</a> (<a class="el" href="classServiceFactory.html">ServiceFactory</a> *factory, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:abf2b7d86b1eab471f61270a0139edbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service factory as a service with the specified properties using the specified template argument as service interface type with the framework.  <a href="#abf2b7d86b1eab471f61270a0139edbcd">More...</a><br/></td></tr>
<tr class="separator:abf2b7d86b1eab471f61270a0139edbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea9afc250bf838ad37659ca37d7bbe7"><td class="memTemplParams" colspan="2">template&lt;class I1 , class I2 &gt; </td></tr>
<tr class="memitem:a0ea9afc250bf838ad37659ca37d7bbe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a0ea9afc250bf838ad37659ca37d7bbe7">RegisterService</a> (<a class="el" href="classServiceFactory.html">ServiceFactory</a> *factory, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a0ea9afc250bf838ad37659ca37d7bbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service factory as a service with the specified properties using the specified template argument as service interface type with the framework.  <a href="#a0ea9afc250bf838ad37659ca37d7bbe7">More...</a><br/></td></tr>
<tr class="separator:a0ea9afc250bf838ad37659ca37d7bbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b6070bc41fada9ec208b73ddab0f64"><td class="memTemplParams" colspan="2">template&lt;class I1 , class I2 , class I3 &gt; </td></tr>
<tr class="memitem:a92b6070bc41fada9ec208b73ddab0f64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt; I1, I2, I3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a92b6070bc41fada9ec208b73ddab0f64">RegisterService</a> (<a class="el" href="classServiceFactory.html">ServiceFactory</a> *factory, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a92b6070bc41fada9ec208b73ddab0f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service factory as a service with the specified properties using the specified template argument as service interface type with the framework.  <a href="#a92b6070bc41fada9ec208b73ddab0f64">More...</a><br/></td></tr>
<tr class="separator:a92b6070bc41fada9ec208b73ddab0f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1be96ec5dcf6452d5e3f236c9fd20a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classServiceReference.html">ServiceReferenceU</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a8b1be96ec5dcf6452d5e3f236c9fd20a">GetServiceReferences</a> (const std::string &amp;clazz, const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:a8b1be96ec5dcf6452d5e3f236c9fd20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects.  <a href="#a8b1be96ec5dcf6452d5e3f236c9fd20a">More...</a><br/></td></tr>
<tr class="separator:a8b1be96ec5dcf6452d5e3f236c9fd20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc06850fd324705a0463d050cbbcbf59"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:adc06850fd324705a0463d050cbbcbf59"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classServiceReference.html">ServiceReference</a><br class="typebreak"/>
&lt; S &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#adc06850fd324705a0463d050cbbcbf59">GetServiceReferences</a> (const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:adc06850fd324705a0463d050cbbcbf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects.  <a href="#adc06850fd324705a0463d050cbbcbf59">More...</a><br/></td></tr>
<tr class="separator:adc06850fd324705a0463d050cbbcbf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47528f02bd276ba9b738b17f60d04f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classServiceReference.html">ServiceReferenceU</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#af47528f02bd276ba9b738b17f60d04f8">GetServiceReference</a> (const std::string &amp;clazz)</td></tr>
<tr class="memdesc:af47528f02bd276ba9b738b17f60d04f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified class.  <a href="#af47528f02bd276ba9b738b17f60d04f8">More...</a><br/></td></tr>
<tr class="separator:af47528f02bd276ba9b738b17f60d04f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a044cfae083209c8ad20f7cfb3f6996"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a8a044cfae083209c8ad20f7cfb3f6996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceReference.html">ServiceReference</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a8a044cfae083209c8ad20f7cfb3f6996">GetServiceReference</a> ()</td></tr>
<tr class="memdesc:a8a044cfae083209c8ad20f7cfb3f6996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified template class argument.  <a href="#a8a044cfae083209c8ad20f7cfb3f6996">More...</a><br/></td></tr>
<tr class="separator:a8a044cfae083209c8ad20f7cfb3f6996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa048066fdb8b9a5cfa250d9b17915437"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#aa048066fdb8b9a5cfa250d9b17915437">GetService</a> (const <a class="el" href="classServiceReferenceBase.html">ServiceReferenceBase</a> &amp;reference)</td></tr>
<tr class="memdesc:aa048066fdb8b9a5cfa250d9b17915437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service object referenced by the specified <code><a class="el" href="classServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> object.  <a href="#aa048066fdb8b9a5cfa250d9b17915437">More...</a><br/></td></tr>
<tr class="separator:aa048066fdb8b9a5cfa250d9b17915437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f80c4ac791fb842ef983c3bfe2c6838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a5f80c4ac791fb842ef983c3bfe2c6838">GetService</a> (const <a class="el" href="classServiceReference.html">ServiceReferenceU</a> &amp;reference)</td></tr>
<tr class="separator:a5f80c4ac791fb842ef983c3bfe2c6838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac"><td class="memTemplItemLeft" align="right" valign="top">S *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac">GetService</a> (const <a class="el" href="classServiceReference.html">ServiceReference</a>&lt; S &gt; &amp;reference)</td></tr>
<tr class="memdesc:aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object.  <a href="#aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac">More...</a><br/></td></tr>
<tr class="separator:aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb59411d496f0f688a3fb3ccb8d50bc7"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:abb59411d496f0f688a3fb3ccb8d50bc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceObjects.html">ServiceObjects</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#abb59411d496f0f688a3fb3ccb8d50bc7">GetServiceObjects</a> (const <a class="el" href="classServiceReference.html">ServiceReference</a>&lt; S &gt; &amp;reference)</td></tr>
<tr class="memdesc:abb59411d496f0f688a3fb3ccb8d50bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classServiceObjects.html" title="Allows multiple service objects for a service to be obtained.">ServiceObjects</a> object for the service referenced by the specified <a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a> object.  <a href="#abb59411d496f0f688a3fb3ccb8d50bc7">More...</a><br/></td></tr>
<tr class="separator:abb59411d496f0f688a3fb3ccb8d50bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410443288166a646e6be0edd6ed77f41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41">UngetService</a> (const <a class="el" href="classServiceReferenceBase.html">ServiceReferenceBase</a> &amp;reference)</td></tr>
<tr class="memdesc:a410443288166a646e6be0edd6ed77f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object.  <a href="#a410443288166a646e6be0edd6ed77f41">More...</a><br/></td></tr>
<tr class="separator:a410443288166a646e6be0edd6ed77f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649b0101ead2e7beef159191484b7913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a649b0101ead2e7beef159191484b7913">AddServiceListener</a> (const ServiceListener &amp;delegate, const std::string &amp;filter=std::string())</td></tr>
<tr class="separator:a649b0101ead2e7beef159191484b7913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59a924bd2d3bf4d8c77abe4a0f61bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ae59a924bd2d3bf4d8c77abe4a0f61bd8">RemoveServiceListener</a> (const ServiceListener &amp;delegate)</td></tr>
<tr class="separator:ae59a924bd2d3bf4d8c77abe4a0f61bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf1334ac62ee534b54f017e2a54df80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#aabf1334ac62ee534b54f017e2a54df80">AddModuleListener</a> (const ModuleListener &amp;delegate)</td></tr>
<tr class="separator:aabf1334ac62ee534b54f017e2a54df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a2b8df55782e13155b456cb36054f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a76a2b8df55782e13155b456cb36054f8">RemoveModuleListener</a> (const ModuleListener &amp;delegate)</td></tr>
<tr class="separator:a76a2b8df55782e13155b456cb36054f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17d515e7a699e1005d379ce7447e8f1"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:ac17d515e7a699e1005d379ce7447e8f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ac17d515e7a699e1005d379ce7447e8f1">AddServiceListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>), const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:ac17d515e7a699e1005d379ce7447e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <code>callback</code> with the specified <code>filter</code> to the context modules's list of listeners.  <a href="#ac17d515e7a699e1005d379ce7447e8f1">More...</a><br/></td></tr>
<tr class="separator:ac17d515e7a699e1005d379ce7447e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceb1d79f61232619c53f2e7f26812ae"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a3ceb1d79f61232619c53f2e7f26812ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a3ceb1d79f61232619c53f2e7f26812ae">RemoveServiceListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>))</td></tr>
<tr class="memdesc:a3ceb1d79f61232619c53f2e7f26812ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified <code>callback</code> from the context module's list of listeners.  <a href="#a3ceb1d79f61232619c53f2e7f26812ae">More...</a><br/></td></tr>
<tr class="separator:a3ceb1d79f61232619c53f2e7f26812ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16d669e0b166372226f23b4eb0536da"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:aa16d669e0b166372226f23b4eb0536da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#aa16d669e0b166372226f23b4eb0536da">AddModuleListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>))</td></tr>
<tr class="memdesc:aa16d669e0b166372226f23b4eb0536da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <code>callback</code> to the context modules's list of listeners.  <a href="#aa16d669e0b166372226f23b4eb0536da">More...</a><br/></td></tr>
<tr class="separator:aa16d669e0b166372226f23b4eb0536da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e370982ef6be2003c7cad780229219"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a83e370982ef6be2003c7cad780229219"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a83e370982ef6be2003c7cad780229219">RemoveModuleListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>))</td></tr>
<tr class="memdesc:a83e370982ef6be2003c7cad780229219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified <code>callback</code> from the context module's list of listeners.  <a href="#a83e370982ef6be2003c7cad780229219">More...</a><br/></td></tr>
<tr class="separator:a83e370982ef6be2003c7cad780229219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A module's execution context within the framework. </p>
<p>The context is used to grant access to other methods so that this module can interact with the Micro Services Framework.</p>
<p><code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> methods allow a module to: </p>
<ul>
<li>
Subscribe to events published by the framework. </li>
<li>
Register service objects with the framework service registry. </li>
<li>
Retrieve <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code>s from the framework service registry. </li>
<li>
Get and release service objects for a referenced service. </li>
<li>
Get the list of modules loaded in the framework. </li>
<li>
Get the <a class="el" href="classModule.html">Module</a> object for a module. </li>
</ul>
<p>A <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object will be created and provided to the module associated with this context when it is loaded using the <a class="el" href="structModuleActivator.html#a1db3f85c15a814a5918eb22725229967">ModuleActivator::Load</a> method. The same <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object will be passed to the module associated with this context when it is unloaded using the <a class="el" href="structModuleActivator.html#a410a3f54b7cad990e8d670450677218c">ModuleActivator::Unload</a> method. A <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is generally for the private use of its associated module and is not meant to be shared with other modules in the module environment.</p>
<p>The <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with a <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is called the <em>context module</em>.</p>
<p>The <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is only valid during the execution of its context module; that is, during the period when the context module is loaded. If the <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is used subsequently, a <code>std::logic_error</code> is thrown. The <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is never reused after its context module is unloaded.</p>
<p>The framework is the only entity that can create <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> objects.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This class is thread safe. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51b9f169eeb6742a4d909ba7a3421730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleContext::~ModuleContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aabf1334ac62ee534b54f017e2a54df80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddModuleListener </td>
          <td>(</td>
          <td class="paramtype">const ModuleListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa16d669e0b166372226f23b4eb0536da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddModuleListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified <code>callback</code> to the context modules's list of listeners. </p>
<p>Listeners are notified when a module has a lifecycle state change.</p>
<p>If the context module's list of listeners already contains a pair <code>(r,c)</code> of <code>receiver</code> and <code>callback</code> such that <code>(r == receiver &amp;&amp; c == callback)</code>, then this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object to connect to. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleEvent.html" title="An event from the Micro Services framework describing a module lifecycle change.">ModuleEvent</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a649b0101ead2e7beef159191484b7913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddServiceListener </td>
          <td>(</td>
          <td class="paramtype">const ServiceListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac17d515e7a699e1005d379ce7447e8f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddServiceListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified <code>callback</code> with the specified <code>filter</code> to the context modules's list of listeners. </p>
<p>See <a class="el" href="classLDAPFilter.html" title="An RFC 1960-based Filter.">LDAPFilter</a> for a description of the filter syntax. Listeners are notified when a service has a lifecycle state change.</p>
<p>You must take care to remove registered listeners befor the <code>receiver</code> object is destroyed. However, the Micro Services framework takes care of removing all listeners registered by this context module's classes after the module is unloaded.</p>
<p>If the context module's list of listeners already contains a pair <code>(r,c)</code> of <code>receiver</code> and <code>callback</code> such that <code>(r == receiver &amp;&amp; c == callback)</code>, then this method replaces that callback's filter (which may be empty) with the specified one (which may be empty).</p>
<p>The callback is called if the filter criteria is met. To filter based upon the class of the service, the filter should reference the <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262" title="Service property identifying all of the class names under which a service was registered in the frame...">ServiceConstants::OBJECTCLASS()</a> property. If <code>filter</code> is empty, all services are considered to match the filter.</p>
<p>When using a <code>filter</code>, it is possible that the <code><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a></code>s for the complete lifecycle of a service will not be delivered to the callback. For example, if the <code>filter</code> only matches when the property <code>x</code> has the value <code>1</code>, the callback will not be called if the service is registered with the property <code>x</code> not set to the value <code>1</code>. Subsequently, when the service is modified setting property <code>x</code> to the value <code>1</code>, the filter will match and the callback will be called with a <code><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a></code> of type <code>MODIFIED</code>. Thus, the callback will not be called with a <code><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a></code> of type <code>REGISTERED</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object to connect to. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to call. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>filter</code> contains an invalid filter string that cannot be parsed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a> </dd>
<dd>
<a class="el" href="classModuleContext.html#ae59a924bd2d3bf4d8c77abe4a0f61bd8">RemoveServiceListener()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae4fc39476ca5a30e0cbe5af26de4b4e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModule.html">Module</a>* ModuleContext::GetModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with this <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code>. </p>
<p>This module is called the context module.</p>
<dl class="section return"><dt>Returns</dt><dd>The <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with this <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26d5bba1c8dff99e35ccef45fb0068d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModule.html">Module</a>* ModuleContext::GetModule </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the module with the specified identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of the module to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object or <code>0</code> if the identifier does not match any previously loaded module. </dd></dl>

</div>
</div>
<a class="anchor" id="afacffe98b55d1c01aeee0c0c69dd70ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::GetModules </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classModule.html">Module</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>modules</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all known modules. </p>
<p>This method returns a list of all modules loaded in the module environment at the time of the call to this method. This list will also contain modules which might already have been unloaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modules</td><td>A std::vector of <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> objects which will hold one object per known module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa048066fdb8b9a5cfa250d9b17915437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ModuleContext::GetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReferenceBase.html">ServiceReferenceBase</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the service object referenced by the specified <code><a class="el" href="classServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> object. </p>
<p>A module's use of a service is tracked by the module's use count of that service. Each time a service's service object is returned by <a class="el" href="classModuleContext.html#aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac">GetService(const ServiceReference&lt;S&gt;&amp;)</a> the context module's use count for that service is incremented by one. Each time the service is released by <a class="el" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41">UngetService(const ServiceReferenceBase&amp;)</a> the context module's use count for that service is decremented by one. </p>
<p>When a module's use count for a service drops to zero, the module should no longer use that service.</p>
<p>This method will always return <code>0</code> when the service associated with this <code>reference</code> has been unregistered.</p>
<p>The following steps are taken to get the service object: </p>
<ol>
<li>
If the service has been unregistered, <code>0</code> is returned. </li>
<li>
The context module's use count for this service is incremented by one. </li>
<li>
If the context module's use count for the service is currently one and the service was registered with an object implementing the <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a></code> interface, the <a class="el" href="classServiceFactory.html#ad11f9698cd9d71ffad77d84b02d0d04e">ServiceFactory::GetService</a> method is called to create a service object for the context module. This service object is cached by the framework. While the context module's use count for the service is greater than zero, subsequent calls to get the services's service object for the context module will return the cached service object. <br/>
 If the <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a></code> object throws an exception, <code>0</code> is returned and a warning is logged. </li>
<li>
The service object for the service is returned. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A reference to the service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A service object for the service associated with <code>reference</code> or <code>0</code> if the service is not registered or the <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a></code> threw an exception. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code><a class="el" href="classServiceReferenceBase.html" title="A reference to a service.">ServiceReferenceBase</a></code> is invalid (default constructed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41" title="Releases the service object referenced by the specified ServiceReference object.">UngetService(const ServiceReferenceBase&amp;)</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5f80c4ac791fb842ef983c3bfe2c6838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a> ModuleContext::GetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReference.html">ServiceReferenceU</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S* ModuleContext::GetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReference.html">ServiceReference</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. </p>
<p>This is a convenience method which is identical to void* <a class="el" href="classModuleContext.html#aa048066fdb8b9a5cfa250d9b17915437" title="Returns the service object referenced by the specified ServiceReferenceBase object.">GetService(const ServiceReferenceBase&amp;)</a> except that it casts the service object to the supplied template argument type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type the service object will be cast to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A service object for the service associated with <code>reference</code> or <code>0</code> if the service is not registered, the <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a></code> threw an exception or the service could not be casted to the desired type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> is invalid (default constructed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa048066fdb8b9a5cfa250d9b17915437" title="Returns the service object referenced by the specified ServiceReferenceBase object.">GetService(const ServiceReferenceBase&amp;)</a> </dd>
<dd>
<a class="el" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41" title="Releases the service object referenced by the specified ServiceReference object.">UngetService(const ServiceReferenceBase&amp;)</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb59411d496f0f688a3fb3ccb8d50bc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceObjects.html">ServiceObjects</a>&lt;S&gt; ModuleContext::GetServiceObjects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReference.html">ServiceReference</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classServiceObjects.html" title="Allows multiple service objects for a service to be obtained.">ServiceObjects</a> object for the service referenced by the specified <a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a> object. </p>
<p>The <a class="el" href="classServiceObjects.html" title="Allows multiple service objects for a service to be obtained.">ServiceObjects</a> object can be used to obtain multiple service objects for services with prototype scope. For services with singleton or module scope, the <a class="el" href="classServiceObjects.html#a85779ccba243ed69fc185b54fc02f7ed" title="Returns a service object for the referenced service.">ServiceObjects::GetService()</a> method behaves the same as the <a class="el" href="classModuleContext.html#aaaadc5f8c7f5d0ffa1ea4d5c5e59e7ac" title="Returns the service object referenced by the specified ServiceReference object.">GetService(const ServiceReference&lt;S&gt;&amp;)</a> method and the ServiceObjects::UngetService(const ServiceReferenceBase&amp;) method behaves the same as the <a class="el" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41" title="Releases the service object referenced by the specified ServiceReference object.">UngetService(const ServiceReferenceBase&amp;)</a> method. That is, only one, use-counted service object is available from the <a class="el" href="classServiceObjects.html" title="Allows multiple service objects for a service to be obtained.">ServiceObjects</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>Type of Service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A reference to the service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceObjects.html" title="Allows multiple service objects for a service to be obtained.">ServiceObjects</a> object for the service associated with the specified reference or an invalid instance if the service is not registered. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a> is invalid (default constructed or the service has been unregistered)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structPrototypeServiceFactory.html" title="A factory for prototype scope services.">PrototypeServiceFactory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af47528f02bd276ba9b738b17f60d04f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceReference.html">ServiceReferenceU</a> ModuleContext::GetServiceReference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clazz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified class. </p>
<p>The returned <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object is valid at the time of the call to this method. However as the Micro Services framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>This method is the same as calling <a class="el" href="classModuleContext.html#a8b1be96ec5dcf6452d5e3f236c9fd20a">ModuleContext::GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> with an empty filter expression. It is provided as a convenience for when the caller is interested in any service that implements the specified class. </p>
<p>If multiple such services exist, the service with the highest ranking (as specified in its <a class="el" href="namespaceServiceConstants.html#a9248db8f7ca4dce942fb3594b1079c3f" title="Service property identifying a service&#39;s ranking number.">ServiceConstants::SERVICE_RANKING()</a> property) is returned. </p>
<p>If there is a tie in ranking, the service with the lowest service ID (as specified in its <a class="el" href="namespaceServiceConstants.html#ac9f9d18808ea2f46376a1489a7b73164" title="Service property identifying a service&#39;s registration number.">ServiceConstants::SERVICE_ID()</a> property); that is, the service that was registered first is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>The class name with which the service was registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object, or an invalid <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> if no services are registered which implement the named class. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If no service was registered under the given class name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a8b1be96ec5dcf6452d5e3f236c9fd20a" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8a044cfae083209c8ad20f7cfb3f6996"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceReference.html">ServiceReference</a>&lt;S&gt; ModuleContext::GetServiceReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified template class argument. </p>
<p>This method is identical to <a class="el" href="classModuleContext.html#af47528f02bd276ba9b738b17f60d04f8" title="Returns a ServiceReference object for a service that implements and was registered under the specifie...">GetServiceReference(const std::string&amp;)</a> except that the class name for the service object is automatically deduced from the template argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type under which the requested service must have been registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object, or an invalid <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> if no services are registered which implement the type <code>S</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>It no service was registered under the given class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#af47528f02bd276ba9b738b17f60d04f8" title="Returns a ServiceReference object for a service that implements and was registered under the specifie...">GetServiceReference(const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classModuleContext.html#adc06850fd324705a0463d050cbbcbf59" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b1be96ec5dcf6452d5e3f236c9fd20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classServiceReference.html">ServiceReferenceU</a>&gt; ModuleContext::GetServiceReferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clazz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects. </p>
<p>The returned list contains services that were registered under the specified class and match the specified filter expression.</p>
<p>The list is valid at the time of the call to this method. However since the Micro Services framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>The specified <code>filter</code> expression is used to select the registered services whose service properties contain keys and values which satisfy the filter expression. See <a class="el" href="classLDAPFilter.html" title="An RFC 1960-based Filter.">LDAPFilter</a> for a description of the filter syntax. If the specified <code>filter</code> is empty, all registered services are considered to match the filter. If the specified <code>filter</code> expression cannot be parsed, an <code>std::invalid_argument</code> will be thrown with a human readable message where the filter became unparsable.</p>
<p>The result is a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects for all services that meet all of the following conditions: </p>
<ul>
<li>
If the specified class name, <code>clazz</code>, is not empty, the service must have been registered with the specified class name. The complete list of class names with which a service was registered is available from the service's <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262">objectClass</a> property. </li>
<li>
If the specified <code>filter</code> is not empty, the filter expression must match the service. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>The class name with which the service was registered or an empty string for all services. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter expression or empty for all services. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects or an empty list if no services are registered which satisfy the search. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code>filter</code> contains an invalid filter expression that cannot be parsed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc06850fd324705a0463d050cbbcbf59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classServiceReference.html">ServiceReference</a>&lt;S&gt; &gt; ModuleContext::GetServiceReferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects. </p>
<p>The returned list contains services that were registered under the interface id of the template argument <code>S</code> and match the specified filter expression.</p>
<p>This method is identical to <a class="el" href="classModuleContext.html#a8b1be96ec5dcf6452d5e3f236c9fd20a" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> except that the class name for the service object is automatically deduced from the template argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type under which the requested service objects must have been registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>The filter expression or empty for all services. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects or an empty list if no services are registered which satisfy the search. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code>filter</code> contains an invalid filter expression that cannot be parsed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If the service type <code>S</code> is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a8b1be96ec5dcf6452d5e3f236c9fd20a" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa68596c589b57246927067742517ce47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MicroServices.html#ga7be3a427a87d460600d4aa9f36a039e4">ServiceRegistrationU</a> ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb">InterfaceMap</a> &amp;&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties under the specified class names into the framework. </p>
<p>A <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object is returned. The <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object is for the private use of the module registering the service and should not be shared with other modules. The registering module is defined to be the context module. Other modules can locate the service by using either the <a class="el" href="classModuleContext.html#a8b1be96ec5dcf6452d5e3f236c9fd20a">GetServiceReferences</a> or <a class="el" href="classModuleContext.html#af47528f02bd276ba9b738b17f60d04f8">GetServiceReference</a> method.</p>
<p>A module can register a service object that implements the <a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> or <a class="el" href="structPrototypeServiceFactory.html" title="A factory for prototype scope services.">PrototypeServiceFactory</a> interface to have more flexibility in providing service objects to other modules.</p>
<p>The following steps are taken when registering a service: </p>
<ol>
<li>
The framework adds the following service properties to the service properties from the specified <code>ServiceProperties</code> (which may be omitted): <br/>
 A property named <a class="el" href="namespaceServiceConstants.html#ac9f9d18808ea2f46376a1489a7b73164" title="Service property identifying a service&#39;s registration number.">ServiceConstants::SERVICE_ID()</a> identifying the registration number of the service <br/>
 A property named <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262" title="Service property identifying all of the class names under which a service was registered in the frame...">ServiceConstants::OBJECTCLASS()</a> containing all the specified classes. <br/>
 A property named <a class="el" href="namespaceServiceConstants.html#a7745368b1cb8eafeafb0259822302b9b" title="Service property identifying a service&#39;s scope.">ServiceConstants::SERVICE_SCOPE()</a> identifying the scope of the service. <br/>
 Properties with these names in the specified <code>ServiceProperties</code> will be ignored. </li>
<li>
The service is added to the framework service registry and may now be used by other modules. </li>
<li>
A service event of type <a class="el" href="classServiceEvent.html#ae7426fe742bd938523b64d43c232a49fa658bb6e21586fc2d75ca841244199cd2" title="This service has been registered.">ServiceEvent::REGISTERED</a> is fired. </li>
<li>
A <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object for this registration is returned. </li>
</ol>
<dl class="section note"><dt>Note</dt><dd>This is a low-level method and should normally not be used directly. Use one of the templated RegisterService methods instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>The service object, which is a map of interface identifiers to raw service pointers. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. The keys in the properties object must all be <code>std::string</code> objects. See <a class="el" href="namespaceServiceConstants.html">ServiceConstants</a> for a list of standard service property keys. Changes should not be made to this object after calling this method. To update the service's properties the <a class="el" href="classServiceRegistrationBase.html#a4e2865300c14dbb04e4efb955d901241">ServiceRegistration::SetProperties</a> method must be called. The set of properties may be omitted if the service has no properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object for use by the module registering the service to update the service's properties or to unregister the service.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If one of the following is true: <ul>
<li>
<code>service</code> is <code>0</code>. </li>
<li>
<code>properties</code> contains case variants of the same key name. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> </dd>
<dd>
<a class="el" href="structPrototypeServiceFactory.html" title="A factory for prototype scope services.">PrototypeServiceFactory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a013068749e6a54ad7aaa73ec691fa3e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt;S&gt; ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties using the specified template argument with the framework. </p>
<p>This method is provided as a convenience when <code>service</code> will only be registered under a single class name whose type is available to the caller. It is otherwise identical to <a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> but should be preferred since it avoids errors in the string literal identifying the class name or interface identifier.</p>
<p>Example usage: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyService : <span class="keyword">public</span> InterfaceA</div>
<div class="line">{};</div>
</div><!-- fragment --><div class="fragment"><div class="line">MyService* myService = <span class="keyword">new</span> MyService;</div>
<div class="line">context-&gt;<a class="code" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService</a>&lt;InterfaceA&gt;(myService);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type under which the service can be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>The service object or a <a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If the service type <code>S</code> is invalid or the <code>service</code> object is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9b6d9800318464a9896ffb7c61a1fb34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I1 , class I2 , class Impl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt;I1,I2&gt; ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype">Impl *&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties using the specified template argument with the framework. </p>
<p>This method is provided as a convenience when registering a service under two interface classes whose type is available to the caller. It is otherwise identical to <a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> but should be preferred since it avoids errors in the string literal identifying the class name or interface identifier.</p>
<p>Example usage: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyService2 : <span class="keyword">public</span> InterfaceA, <span class="keyword">public</span> InterfaceB</div>
<div class="line">{};</div>
</div><!-- fragment --><div class="fragment"><div class="line">MyService2* myService = <span class="keyword">new</span> MyService2;</div>
<div class="line">context-&gt;<a class="code" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService</a>&lt;InterfaceA, InterfaceB&gt;(myService);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I1</td><td>The first interface type under which the service can be located. </td></tr>
    <tr><td class="paramname">I2</td><td>The second interface type under which the service can be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>The service object or a <a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If the service type <code>S</code> is invalid or the <code>service</code> object is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76ef7a4df92f91a62c50df4ca9100c70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I1 , class I2 , class I3 , class Impl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt;I1,I2,I3&gt; ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype">Impl *&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties using the specified template argument with the framework. </p>
<p>This method is identical to the <a class="el" href="classModuleContext.html#a9b6d9800318464a9896ffb7c61a1fb34" title="Registers the specified service object with the specified properties using the specified template arg...">RegisterService&lt;I1,I2,Impl&gt;(Impl*, const ServiceProperties&amp;)</a> method except that it supports three service interface types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I1</td><td>The first interface type under which the service can be located. </td></tr>
    <tr><td class="paramname">I2</td><td>The second interface type under which the service can be located. </td></tr>
    <tr><td class="paramname">I3</td><td>The third interface type under which the service can be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>The service object or a <a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If the service type <code>S</code> is invalid or the <code>service</code> object is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf2b7d86b1eab471f61270a0139edbcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt;S&gt; ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classServiceFactory.html">ServiceFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service factory as a service with the specified properties using the specified template argument as service interface type with the framework. </p>
<p>This method is provided as a convenience when <code>factory</code> will only be registered under a single class name whose type is available to the caller. It is otherwise identical to <a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> but should be preferred since it avoids errors in the string literal identifying the class name or interface identifier.</p>
<p>Example usage: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyService : <span class="keyword">public</span> InterfaceA</div>
<div class="line">{};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>MyServiceFactory : <span class="keyword">public</span> <a class="code" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">virtual</span> <a class="code" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb" title="A map containing interfaces ids and their corresponding service object pointers.">InterfaceMap</a> <a class="code" href="classModuleContext.html#aa048066fdb8b9a5cfa250d9b17915437" title="Returns the service object referenced by the specified ServiceReferenceBase object.">GetService</a>(<a class="code" href="classModule.html" title="Represents a CppMicroServices module.">Module</a>* <span class="comment">/*module*/</span>, <span class="keyword">const</span> <a class="code" href="classServiceRegistrationBase.html" title="A registered service.">ServiceRegistrationBase</a>&amp; <span class="comment">/*registration*/</span>)</div>
<div class="line">  {</div>
<div class="line">    MyService* myService = <span class="keyword">new</span> MyService;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structMakeInterfaceMap.html" title="Helper class for constructing InterfaceMap instances based on service implementations or service fact...">MakeInterfaceMap&lt;InterfaceA&gt;</a>(myService);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41" title="Releases the service object referenced by the specified ServiceReference object.">UngetService</a>(<a class="code" href="classModule.html" title="Represents a CppMicroServices module.">Module</a>* <span class="comment">/*module*/</span>, <span class="keyword">const</span> <a class="code" href="classServiceRegistrationBase.html" title="A registered service.">ServiceRegistrationBase</a>&amp; <span class="comment">/*registration*/</span>,</div>
<div class="line">                            <span class="keyword">const</span> <a class="code" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb" title="A map containing interfaces ids and their corresponding service object pointers.">InterfaceMap</a>&amp; service)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> ExtractInterface&lt;InterfaceA&gt;(service);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">MyServiceFactory* myServiceFactory = <span class="keyword">new</span> MyServiceFactory;</div>
<div class="line">context-&gt;<a class="code" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService</a>&lt;InterfaceA&gt;(myServiceFactory);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type under which the service can be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The <a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> or <a class="el" href="structPrototypeServiceFactory.html" title="A factory for prototype scope services.">PrototypeServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If the service type <code>S</code> is invalid or the <code>service</code> factory object is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ea9afc250bf838ad37659ca37d7bbe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I1 , class I2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt;I1,I2&gt; ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classServiceFactory.html">ServiceFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service factory as a service with the specified properties using the specified template argument as service interface type with the framework. </p>
<p>This method is identical to the <a class="el" href="classModuleContext.html#abf2b7d86b1eab471f61270a0139edbcd" title="Registers the specified service factory as a service with the specified properties using the specifie...">RegisterService&lt;S&gt;(ServiceFactory*, const ServiceProperties&amp;)</a> method except that it supports two service interface types.</p>
<p>Example usage: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyService2 : <span class="keyword">public</span> InterfaceA, <span class="keyword">public</span> InterfaceB</div>
<div class="line">{};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>MyServiceFactory : <span class="keyword">public</span> <a class="code" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">virtual</span> <a class="code" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb" title="A map containing interfaces ids and their corresponding service object pointers.">InterfaceMap</a> <a class="code" href="classModuleContext.html#aa048066fdb8b9a5cfa250d9b17915437" title="Returns the service object referenced by the specified ServiceReferenceBase object.">GetService</a>(<a class="code" href="classModule.html" title="Represents a CppMicroServices module.">Module</a>* <span class="comment">/*module*/</span>, <span class="keyword">const</span> <a class="code" href="classServiceRegistrationBase.html" title="A registered service.">ServiceRegistrationBase</a>&amp; <span class="comment">/*registration*/</span>)</div>
<div class="line">  {</div>
<div class="line">    MyService2* myService = <span class="keyword">new</span> MyService2;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structMakeInterfaceMap.html" title="Helper class for constructing InterfaceMap instances based on service implementations or service fact...">MakeInterfaceMap&lt;InterfaceA,InterfaceB&gt;</a>(myService);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classModuleContext.html#a410443288166a646e6be0edd6ed77f41" title="Releases the service object referenced by the specified ServiceReference object.">UngetService</a>(<a class="code" href="classModule.html" title="Represents a CppMicroServices module.">Module</a>* <span class="comment">/*module*/</span>, <span class="keyword">const</span> <a class="code" href="classServiceRegistrationBase.html" title="A registered service.">ServiceRegistrationBase</a>&amp; <span class="comment">/*registration*/</span>,</div>
<div class="line">                            <span class="keyword">const</span> <a class="code" href="group__MicroServices.html#ga5b79f53257c6f566b36781eca6af9beb" title="A map containing interfaces ids and their corresponding service object pointers.">InterfaceMap</a>&amp; service)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> ExtractInterface&lt;InterfaceA&gt;(service);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">MyServiceFactory* myServiceFactory = <span class="keyword">new</span> MyServiceFactory;</div>
<div class="line">context-&gt;<a class="code" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService</a>&lt;InterfaceA,InterfaceB&gt;(<span class="keyword">static_cast&lt;</span><a class="code" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a>*<span class="keyword">&gt;</span>(myServiceFactory));</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I1</td><td>The first interface type under which the service can be located. </td></tr>
    <tr><td class="paramname">I2</td><td>The second interface type under which the service can be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The <a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> or <a class="el" href="structPrototypeServiceFactory.html" title="A factory for prototype scope services.">PrototypeServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If the service type <code>S</code> is invalid or the <code>service</code> factory object is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a92b6070bc41fada9ec208b73ddab0f64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I1 , class I2 , class I3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&lt;I1,I2,I3&gt; ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classServiceFactory.html">ServiceFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service factory as a service with the specified properties using the specified template argument as service interface type with the framework. </p>
<p>This method is identical to the <a class="el" href="classModuleContext.html#abf2b7d86b1eab471f61270a0139edbcd" title="Registers the specified service factory as a service with the specified properties using the specifie...">RegisterService&lt;S&gt;(ServiceFactory*, const ServiceProperties&amp;)</a> method except that it supports three service interface types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I1</td><td>The first interface type under which the service can be located. </td></tr>
    <tr><td class="paramname">I2</td><td>The second interface type under which the service can be located. </td></tr>
    <tr><td class="paramname">I3</td><td>The third interface type under which the service can be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The <a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> or <a class="el" href="structPrototypeServiceFactory.html" title="A factory for prototype scope services.">PrototypeServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If the service type <code>S</code> is invalid or the <code>service</code> factory object is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa68596c589b57246927067742517ce47" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService(const InterfaceMap&amp;, const ServiceProperties&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76a2b8df55782e13155b456cb36054f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveModuleListener </td>
          <td>(</td>
          <td class="paramtype">const ModuleListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83e370982ef6be2003c7cad780229219"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveModuleListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified <code>callback</code> from the context module's list of listeners. </p>
<p>If the <code>(receiver,callback)</code> pair is not contained in this context module's list of listeners, this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be removed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object from which to disconnect. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aabf1334ac62ee534b54f017e2a54df80">AddModuleListener()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae59a924bd2d3bf4d8c77abe4a0f61bd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveServiceListener </td>
          <td>(</td>
          <td class="paramtype">const ServiceListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ceb1d79f61232619c53f2e7f26812ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveServiceListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified <code>callback</code> from the context module's list of listeners. </p>
<p>If the <code>(receiver,callback)</code> pair is not contained in this context module's list of listeners, this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be removed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object from which to disconnect. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a649b0101ead2e7beef159191484b7913">AddServiceListener()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a410443288166a646e6be0edd6ed77f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ModuleContext::UngetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReferenceBase.html">ServiceReferenceBase</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. </p>
<p>If the context module's use count for the service is zero, this method returns <code>false</code>. Otherwise, the context modules's use count for the service is decremented by one.</p>
<p>The service's service object should no longer be used and all references to it should be destroyed when a module's use count for the service drops to zero.</p>
<p>The following steps are taken to unget the service object: </p>
<ol>
<li>
If the context module's use count for the service is zero or the service has been unregistered, <code>false</code> is returned. </li>
<li>
The context module's use count for this service is decremented by one. </li>
<li>
If the context module's use count for the service is currently zero and the service was registered with a <code><a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a></code> object, the <a class="el" href="classServiceFactory.html#aa80a6cbdc96eec60cf135afabcbb1a65" title="Releases a service object.">ServiceFactory::UngetService</a> method is called to release the service object for the context module. </li>
<li>
<code>true</code> is returned. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A reference to the service to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the context module's use count for the service is zero or if the service has been unregistered; <code>true</code> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aa048066fdb8b9a5cfa250d9b17915437" title="Returns the service object referenced by the specified ServiceReferenceBase object.">GetService</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="A factory for module scope services.">ServiceFactory</a> </dd></dl>

</div>
</div>
</div><!-- contents -->

  <hr class="footer"/>
  <address class="footer"><small>Generated on Fri Aug 16 2013 for C++ Micro Services 1.99.0 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.3.1
</small></address>
