---
layout: default
title: ModuleContext Class Reference
---
  <head>
    <title>C++ Micro Services: ModuleContext Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
  </head>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classModuleContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ModuleContext Class Reference<div class="ingroups"><a class="el" href="group__MicroServices.html">Micro Services Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A module's execution context within the framework.  
 <a href="classModuleContext.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51b9f169eeb6742a4d909ba7a3421730"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a51b9f169eeb6742a4d909ba7a3421730">~ModuleContext</a> ()</td></tr>
<tr class="separator:a51b9f169eeb6742a4d909ba7a3421730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fc39476ca5a30e0cbe5af26de4b4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModule.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ae4fc39476ca5a30e0cbe5af26de4b4e3">GetModule</a> () const </td></tr>
<tr class="memdesc:ae4fc39476ca5a30e0cbe5af26de4b4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with this <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code>.  <a href="#ae4fc39476ca5a30e0cbe5af26de4b4e3">More...</a><br/></td></tr>
<tr class="separator:ae4fc39476ca5a30e0cbe5af26de4b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d5bba1c8dff99e35ccef45fb0068d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModule.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a26d5bba1c8dff99e35ccef45fb0068d3">GetModule</a> (long id) const </td></tr>
<tr class="memdesc:a26d5bba1c8dff99e35ccef45fb0068d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the module with the specified identifier.  <a href="#a26d5bba1c8dff99e35ccef45fb0068d3">More...</a><br/></td></tr>
<tr class="separator:a26d5bba1c8dff99e35ccef45fb0068d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacffe98b55d1c01aeee0c0c69dd70ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#afacffe98b55d1c01aeee0c0c69dd70ee">GetModules</a> (std::vector&lt; <a class="el" href="classModule.html">Module</a> * &gt; &amp;modules) const </td></tr>
<tr class="memdesc:afacffe98b55d1c01aeee0c0c69dd70ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all known modules.  <a href="#afacffe98b55d1c01aeee0c0c69dd70ee">More...</a><br/></td></tr>
<tr class="separator:afacffe98b55d1c01aeee0c0c69dd70ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7399fcc65ae1625cc06e4010e9e262d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a7399fcc65ae1625cc06e4010e9e262d6">RegisterService</a> (const std::list&lt; std::string &gt; &amp;clazzes, us::Base *service, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a7399fcc65ae1625cc06e4010e9e262d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties under the specified class names into the framework.  <a href="#a7399fcc65ae1625cc06e4010e9e262d6">More...</a><br/></td></tr>
<tr class="separator:a7399fcc65ae1625cc06e4010e9e262d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f83b5bac7475b7cce0a006696a5102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ae5f83b5bac7475b7cce0a006696a5102">RegisterService</a> (const char *clazz, us::Base *service, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:ae5f83b5bac7475b7cce0a006696a5102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties under the specified class name with the framework.  <a href="#ae5f83b5bac7475b7cce0a006696a5102">More...</a><br/></td></tr>
<tr class="separator:ae5f83b5bac7475b7cce0a006696a5102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ff1db40f40f1bf3c9435458de4b00b"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a88ff1db40f40f1bf3c9435458de4b00b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a88ff1db40f40f1bf3c9435458de4b00b">RegisterService</a> (us::Base *service, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;properties=<a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>())</td></tr>
<tr class="memdesc:a88ff1db40f40f1bf3c9435458de4b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the specified service object with the specified properties using the specified template argument with the framework.  <a href="#a88ff1db40f40f1bf3c9435458de4b00b">More...</a><br/></td></tr>
<tr class="separator:a88ff1db40f40f1bf3c9435458de4b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9a232ed28caf664ffb994e24451bed"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classServiceReference.html">ServiceReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a9d9a232ed28caf664ffb994e24451bed">GetServiceReferences</a> (const std::string &amp;clazz, const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:a9d9a232ed28caf664ffb994e24451bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects.  <a href="#a9d9a232ed28caf664ffb994e24451bed">More...</a><br/></td></tr>
<tr class="separator:a9d9a232ed28caf664ffb994e24451bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92776b8bf122ed3f28e4528bb9cd3e8"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ad92776b8bf122ed3f28e4528bb9cd3e8"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classServiceReference.html">ServiceReference</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ad92776b8bf122ed3f28e4528bb9cd3e8">GetServiceReferences</a> (const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:ad92776b8bf122ed3f28e4528bb9cd3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects.  <a href="#ad92776b8bf122ed3f28e4528bb9cd3e8">More...</a><br/></td></tr>
<tr class="separator:ad92776b8bf122ed3f28e4528bb9cd3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e3f72bad1067aba49283e851448253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classServiceReference.html">ServiceReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ad4e3f72bad1067aba49283e851448253">GetServiceReference</a> (const std::string &amp;clazz)</td></tr>
<tr class="memdesc:ad4e3f72bad1067aba49283e851448253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified class.  <a href="#ad4e3f72bad1067aba49283e851448253">More...</a><br/></td></tr>
<tr class="separator:ad4e3f72bad1067aba49283e851448253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a5e5dbed9c5aa948104a103a1d78f3"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a24a5e5dbed9c5aa948104a103a1d78f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classServiceReference.html">ServiceReference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a24a5e5dbed9c5aa948104a103a1d78f3">GetServiceReference</a> ()</td></tr>
<tr class="memdesc:a24a5e5dbed9c5aa948104a103a1d78f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified template class argument.  <a href="#a24a5e5dbed9c5aa948104a103a1d78f3">More...</a><br/></td></tr>
<tr class="separator:a24a5e5dbed9c5aa948104a103a1d78f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdfe2bcbae824b0cd6aa79bc4489850"><td class="memItemLeft" align="right" valign="top">us::Base *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a2bdfe2bcbae824b0cd6aa79bc4489850">GetService</a> (const <a class="el" href="classServiceReference.html">ServiceReference</a> &amp;reference)</td></tr>
<tr class="memdesc:a2bdfe2bcbae824b0cd6aa79bc4489850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object.  <a href="#a2bdfe2bcbae824b0cd6aa79bc4489850">More...</a><br/></td></tr>
<tr class="separator:a2bdfe2bcbae824b0cd6aa79bc4489850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1fac3d6fcb5bcce25aa183d7487cbe"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a4c1fac3d6fcb5bcce25aa183d7487cbe"><td class="memTemplItemLeft" align="right" valign="top">S *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a4c1fac3d6fcb5bcce25aa183d7487cbe">GetService</a> (const <a class="el" href="classServiceReference.html">ServiceReference</a> &amp;reference)</td></tr>
<tr class="memdesc:a4c1fac3d6fcb5bcce25aa183d7487cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object.  <a href="#a4c1fac3d6fcb5bcce25aa183d7487cbe">More...</a><br/></td></tr>
<tr class="separator:a4c1fac3d6fcb5bcce25aa183d7487cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070a6218b13e363098d546425c02f13c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a070a6218b13e363098d546425c02f13c">UngetService</a> (const <a class="el" href="classServiceReference.html">ServiceReference</a> &amp;reference)</td></tr>
<tr class="memdesc:a070a6218b13e363098d546425c02f13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object.  <a href="#a070a6218b13e363098d546425c02f13c">More...</a><br/></td></tr>
<tr class="separator:a070a6218b13e363098d546425c02f13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649b0101ead2e7beef159191484b7913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a649b0101ead2e7beef159191484b7913">AddServiceListener</a> (const ServiceListener &amp;delegate, const std::string &amp;filter=std::string())</td></tr>
<tr class="separator:a649b0101ead2e7beef159191484b7913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59a924bd2d3bf4d8c77abe4a0f61bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ae59a924bd2d3bf4d8c77abe4a0f61bd8">RemoveServiceListener</a> (const ServiceListener &amp;delegate)</td></tr>
<tr class="separator:ae59a924bd2d3bf4d8c77abe4a0f61bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf1334ac62ee534b54f017e2a54df80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#aabf1334ac62ee534b54f017e2a54df80">AddModuleListener</a> (const ModuleListener &amp;delegate)</td></tr>
<tr class="separator:aabf1334ac62ee534b54f017e2a54df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a2b8df55782e13155b456cb36054f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a76a2b8df55782e13155b456cb36054f8">RemoveModuleListener</a> (const ModuleListener &amp;delegate)</td></tr>
<tr class="separator:a76a2b8df55782e13155b456cb36054f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17d515e7a699e1005d379ce7447e8f1"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:ac17d515e7a699e1005d379ce7447e8f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#ac17d515e7a699e1005d379ce7447e8f1">AddServiceListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>), const std::string &amp;filter=std::string())</td></tr>
<tr class="memdesc:ac17d515e7a699e1005d379ce7447e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <code>callback</code> with the specified <code>filter</code> to the context modules's list of listeners.  <a href="#ac17d515e7a699e1005d379ce7447e8f1">More...</a><br/></td></tr>
<tr class="separator:ac17d515e7a699e1005d379ce7447e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceb1d79f61232619c53f2e7f26812ae"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a3ceb1d79f61232619c53f2e7f26812ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a3ceb1d79f61232619c53f2e7f26812ae">RemoveServiceListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>))</td></tr>
<tr class="memdesc:a3ceb1d79f61232619c53f2e7f26812ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified <code>callback</code> from the context module's list of listeners.  <a href="#a3ceb1d79f61232619c53f2e7f26812ae">More...</a><br/></td></tr>
<tr class="separator:a3ceb1d79f61232619c53f2e7f26812ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16d669e0b166372226f23b4eb0536da"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:aa16d669e0b166372226f23b4eb0536da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#aa16d669e0b166372226f23b4eb0536da">AddModuleListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>))</td></tr>
<tr class="memdesc:aa16d669e0b166372226f23b4eb0536da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <code>callback</code> to the context modules's list of listeners.  <a href="#aa16d669e0b166372226f23b4eb0536da">More...</a><br/></td></tr>
<tr class="separator:aa16d669e0b166372226f23b4eb0536da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e370982ef6be2003c7cad780229219"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a83e370982ef6be2003c7cad780229219"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModuleContext.html#a83e370982ef6be2003c7cad780229219">RemoveModuleListener</a> (R *receiver, void(R::*callback)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>))</td></tr>
<tr class="memdesc:a83e370982ef6be2003c7cad780229219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified <code>callback</code> from the context module's list of listeners.  <a href="#a83e370982ef6be2003c7cad780229219">More...</a><br/></td></tr>
<tr class="separator:a83e370982ef6be2003c7cad780229219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A module's execution context within the framework. </p>
<p>The context is used to grant access to other methods so that this module can interact with the Micro Services Framework.</p>
<p><code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> methods allow a module to: </p>
<ul>
<li>
Subscribe to events published by the framework. </li>
<li>
Register service objects with the framework service registry. </li>
<li>
Retrieve <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code>s from the framework service registry. </li>
<li>
Get and release service objects for a referenced service. </li>
<li>
Get the list of modules loaded in the framework. </li>
<li>
Get the <a class="el" href="classModule.html">Module</a> object for a module. </li>
</ul>
<p>A <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object will be created and provided to the module associated with this context when it is loaded using the <a class="el" href="structModuleActivator.html#a1db3f85c15a814a5918eb22725229967">ModuleActivator::Load</a> method. The same <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object will be passed to the module associated with this context when it is unloaded using the <a class="el" href="structModuleActivator.html#a410a3f54b7cad990e8d670450677218c">ModuleActivator::Unload</a> method. A <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is generally for the private use of its associated module and is not meant to be shared with other modules in the module environment.</p>
<p>The <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with a <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is called the <em>context module</em>.</p>
<p>The <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is only valid during the execution of its context module; that is, during the period when the context module is loaded. If the <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is used subsequently, a <code>std::logic_error</code> is thrown. The <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> object is never reused after its context module is unloaded.</p>
<p>The framework is the only entity that can create <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code> objects.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This class is thread safe. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51b9f169eeb6742a4d909ba7a3421730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleContext::~ModuleContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aabf1334ac62ee534b54f017e2a54df80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddModuleListener </td>
          <td>(</td>
          <td class="paramtype">const ModuleListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa16d669e0b166372226f23b4eb0536da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddModuleListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified <code>callback</code> to the context modules's list of listeners. </p>
<p>Listeners are notified when a module has a lifecycle state change.</p>
<p>If the context module's list of listeners already contains a pair <code>(r,c)</code> of <code>receiver</code> and <code>callback</code> such that <code>(r == receiver &amp;&amp; c == callback)</code>, then this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object to connect to. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleEvent.html" title="An event from the Micro Services framework describing a module lifecycle change.">ModuleEvent</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a649b0101ead2e7beef159191484b7913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddServiceListener </td>
          <td>(</td>
          <td class="paramtype">const ServiceListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac17d515e7a699e1005d379ce7447e8f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::AddServiceListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified <code>callback</code> with the specified <code>filter</code> to the context modules's list of listeners. </p>
<p>See <a class="el" href="classLDAPFilter.html" title="An RFC 1960-based Filter.">LDAPFilter</a> for a description of the filter syntax. Listeners are notified when a service has a lifecycle state change.</p>
<p>You must take care to remove registered listeners befor the <code>receiver</code> object is destroyed. However, the Micro Services framework takes care of removing all listeners registered by this context module's classes after the module is unloaded.</p>
<p>If the context module's list of listeners already contains a pair <code>(r,c)</code> of <code>receiver</code> and <code>callback</code> such that <code>(r == receiver &amp;&amp; c == callback)</code>, then this method replaces that callback's filter (which may be empty) with the specified one (which may be empty).</p>
<p>The callback is called if the filter criteria is met. To filter based upon the class of the service, the filter should reference the <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262" title="Service property identifying all of the class names under which a service was registered in the frame...">ServiceConstants::OBJECTCLASS()</a> property. If <code>filter</code> is empty, all services are considered to match the filter.</p>
<p>When using a <code>filter</code>, it is possible that the <code><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a></code>s for the complete lifecycle of a service will not be delivered to the callback. For example, if the <code>filter</code> only matches when the property <code>x</code> has the value <code>1</code>, the callback will not be called if the service is registered with the property <code>x</code> not set to the value <code>1</code>. Subsequently, when the service is modified setting property <code>x</code> to the value <code>1</code>, the filter will match and the callback will be called with a <code><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a></code> of type <code>MODIFIED</code>. Thus, the callback will not be called with a <code><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a></code> of type <code>REGISTERED</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object to connect to. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to call. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter criteria. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If <code>filter</code> contains an invalid filter string that cannot be parsed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classServiceEvent.html" title="An event from the Micro Services framework describing a service lifecycle change.">ServiceEvent</a> </dd>
<dd>
<a class="el" href="classModuleContext.html#ae59a924bd2d3bf4d8c77abe4a0f61bd8">RemoveServiceListener()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae4fc39476ca5a30e0cbe5af26de4b4e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModule.html">Module</a>* ModuleContext::GetModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with this <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code>. </p>
<p>This module is called the context module.</p>
<dl class="section return"><dt>Returns</dt><dd>The <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object associated with this <code><a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a></code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26d5bba1c8dff99e35ccef45fb0068d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModule.html">Module</a>* ModuleContext::GetModule </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the module with the specified identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of the module to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> object or <code>0</code> if the identifier does not match any previously loaded module. </dd></dl>

</div>
</div>
<a class="anchor" id="afacffe98b55d1c01aeee0c0c69dd70ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::GetModules </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classModule.html">Module</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>modules</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all known modules. </p>
<p>This method returns a list of all modules loaded in the module environment at the time of the call to this method. This list will also contain modules which might already have been unloaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modules</td><td>A std::vector of <code><a class="el" href="classModule.html" title="Represents a CppMicroServices module.">Module</a></code> objects which will hold one object per known module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bdfe2bcbae824b0cd6aa79bc4489850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">us::Base* ModuleContext::GetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReference.html">ServiceReference</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. </p>
<p>A module's use of a service is tracked by the module's use count of that service. Each time a service's service object is returned by <a class="el" href="classModuleContext.html#a2bdfe2bcbae824b0cd6aa79bc4489850">GetService(const ServiceReference&amp;)</a> the context module's use count for that service is incremented by one. Each time the service is released by <a class="el" href="classModuleContext.html#a070a6218b13e363098d546425c02f13c">UngetService(const ServiceReference&amp;)</a> the context module's use count for that service is decremented by one. </p>
<p>When a module's use count for a service drops to zero, the module should no longer use that service.</p>
<p>This method will always return <code>0</code> when the service associated with this <code>reference</code> has been unregistered.</p>
<p>The following steps are taken to get the service object: </p>
<ol>
<li>
If the service has been unregistered, <code>0</code> is returned. </li>
<li>
The context module's use count for this service is incremented by one. </li>
<li>
If the context module's use count for the service is currently one and the service was registered with an object implementing the <code><a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a></code> interface, the <a class="el" href="classServiceFactory.html#aacb476e162ce8bc12509cb3bdb2adebf">ServiceFactory::GetService</a> method is called to create a service object for the context module. This service object is cached by the framework. While the context module's use count for the service is greater than zero, subsequent calls to get the services's service object for the context module will return the cached service object. <br/>
 If the <code><a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a></code> object throws an exception, <code>0</code> is returned and a warning is logged. </li>
<li>
The service object for the service is returned. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A reference to the service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A service object for the service associated with <code>reference</code> or <code>0</code> if the service is not registered or the <code><a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a></code> threw an exception. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> is invalid (default constructed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a070a6218b13e363098d546425c02f13c" title="Releases the service object referenced by the specified ServiceReference object.">UngetService(const ServiceReference&amp;)</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c1fac3d6fcb5bcce25aa183d7487cbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S* ModuleContext::GetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReference.html">ServiceReference</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. </p>
<p>This is a convenience method which is identical to US_BASECLASS_NAME* <a class="el" href="classModuleContext.html#a2bdfe2bcbae824b0cd6aa79bc4489850" title="Returns the service object referenced by the specified ServiceReference object.">GetService(const ServiceReference&amp;)</a> except that it casts the service object to the supplied template argument type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type the service object will be cast to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A service object for the service associated with <code>reference</code> or <code>0</code> if the service is not registered, the <code><a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a></code> threw an exception or the service could not be casted to the desired type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> is invalid (default constructed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a2bdfe2bcbae824b0cd6aa79bc4489850" title="Returns the service object referenced by the specified ServiceReference object.">GetService(const ServiceReference&amp;)</a> </dd>
<dd>
<a class="el" href="classModuleContext.html#a070a6218b13e363098d546425c02f13c" title="Releases the service object referenced by the specified ServiceReference object.">UngetService(const ServiceReference&amp;)</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e3f72bad1067aba49283e851448253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceReference.html">ServiceReference</a> ModuleContext::GetServiceReference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clazz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified class. </p>
<p>The returned <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object is valid at the time of the call to this method. However as the Micro Services framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>This method is the same as calling <a class="el" href="classModuleContext.html#a9d9a232ed28caf664ffb994e24451bed">ModuleContext::GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> with an empty filter expression. It is provided as a convenience for when the caller is interested in any service that implements the specified class. </p>
<p>If multiple such services exist, the service with the highest ranking (as specified in its <a class="el" href="namespaceServiceConstants.html#a9248db8f7ca4dce942fb3594b1079c3f" title="Service property identifying a service&#39;s ranking number.">ServiceConstants::SERVICE_RANKING()</a> property) is returned. </p>
<p>If there is a tie in ranking, the service with the lowest service ID (as specified in its <a class="el" href="namespaceServiceConstants.html#ac9f9d18808ea2f46376a1489a7b73164" title="Service property identifying a service&#39;s registration number.">ServiceConstants::SERVICE_ID()</a> property); that is, the service that was registered first is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>The class name with which the service was registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object, or an invalid <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> if no services are registered which implement the named class. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>If no service was registered under the given class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a9d9a232ed28caf664ffb994e24451bed" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a24a5e5dbed9c5aa948104a103a1d78f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceReference.html">ServiceReference</a> ModuleContext::GetServiceReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object for a service that implements and was registered under the specified template class argument. </p>
<p>This method is identical to <a class="el" href="classModuleContext.html#ad4e3f72bad1067aba49283e851448253" title="Returns a ServiceReference object for a service that implements and was registered under the specifie...">GetServiceReference(const std::string&amp;)</a> except that the class name for the service object is automatically deduced from the template argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type under which the requested service must have been registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object, or an invalid <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> if no services are registered which implement the type <code>S</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="classServiceException.html" title="A service exception used to indicate that a service problem occurred.">ServiceException</a></td><td>It no service was registered under the given class name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#ad4e3f72bad1067aba49283e851448253" title="Returns a ServiceReference object for a service that implements and was registered under the specifie...">GetServiceReference(const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classModuleContext.html#ad92776b8bf122ed3f28e4528bb9cd3e8" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9a232ed28caf664ffb994e24451bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classServiceReference.html">ServiceReference</a>&gt; ModuleContext::GetServiceReferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clazz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects. </p>
<p>The returned list contains services that were registered under the specified class and match the specified filter expression.</p>
<p>The list is valid at the time of the call to this method. However since the Micro Services framework is a very dynamic environment, services can be modified or unregistered at any time.</p>
<p>The specified <code>filter</code> expression is used to select the registered services whose service properties contain keys and values which satisfy the filter expression. See <a class="el" href="classLDAPFilter.html" title="An RFC 1960-based Filter.">LDAPFilter</a> for a description of the filter syntax. If the specified <code>filter</code> is empty, all registered services are considered to match the filter. If the specified <code>filter</code> expression cannot be parsed, an <code>std::invalid_argument</code> will be thrown with a human readable message where the filter became unparsable.</p>
<p>The result is a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects for all services that meet all of the following conditions: </p>
<ul>
<li>
If the specified class name, <code>clazz</code>, is not empty, the service must have been registered with the specified class name. The complete list of class names with which a service was registered is available from the service's <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262">objectClass</a> property. </li>
<li>
If the specified <code>filter</code> is not empty, the filter expression must match the service. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>The class name with which the service was registered or an empty string for all services. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter expression or empty for all services. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects or an empty list if no services are registered which satisfy the search. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code>filter</code> contains an invalid filter expression that cannot be parsed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad92776b8bf122ed3f28e4528bb9cd3e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classServiceReference.html">ServiceReference</a>&gt; ModuleContext::GetServiceReferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects. </p>
<p>The returned list contains services that were registered under the interface id of the template argument <code>S</code> and match the specified filter expression.</p>
<p>This method is identical to <a class="el" href="classModuleContext.html#a9d9a232ed28caf664ffb994e24451bed" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> except that the class name for the service object is automatically deduced from the template argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type under which the requested service objects must have been registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>The filter expression or empty for all services. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> objects or an empty list if no services are registered which satisfy the search. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the specified <code>filter</code> contains an invalid filter expression that cannot be parsed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a9d9a232ed28caf664ffb994e24451bed" title="Returns a list of ServiceReference objects.">GetServiceReferences(const std::string&amp;, const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7399fcc65ae1625cc06e4010e9e262d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a> ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>clazzes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">us::Base *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties under the specified class names into the framework. </p>
<p>A <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object is returned. The <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object is for the private use of the module registering the service and should not be shared with other modules. The registering module is defined to be the context module. Other modules can locate the service by using either the <a class="el" href="classModuleContext.html#a9d9a232ed28caf664ffb994e24451bed">GetServiceReferences</a> or <a class="el" href="classModuleContext.html#ad4e3f72bad1067aba49283e851448253">GetServiceReference</a> method.</p>
<p>A module can register a service object that implements the <a class="el" href="classServiceFactory.html">ServiceFactory</a> interface to have more flexibility in providing service objects to other modules.</p>
<p>The following steps are taken when registering a service: </p>
<ol>
<li>
The framework adds the following service properties to the service properties from the specified <code>ServiceProperties</code> (which may be omitted): <br/>
 A property named <a class="el" href="namespaceServiceConstants.html#ac9f9d18808ea2f46376a1489a7b73164" title="Service property identifying a service&#39;s registration number.">ServiceConstants::SERVICE_ID()</a> identifying the registration number of the service <br/>
 A property named <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262" title="Service property identifying all of the class names under which a service was registered in the frame...">ServiceConstants::OBJECTCLASS()</a> containing all the specified classes. <br/>
 Properties with these names in the specified <code>ServiceProperties</code> will be ignored. </li>
<li>
The service is added to the framework service registry and may now be used by other modules. </li>
<li>
A service event of type <a class="el" href="classServiceEvent.html#ae7426fe742bd938523b64d43c232a49fa658bb6e21586fc2d75ca841244199cd2" title="This service has been registered.">ServiceEvent::REGISTERED</a> is fired. </li>
<li>
A <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object for this registration is returned. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazzes</td><td>The class names under which the service can be located. The class names will be stored in the service's properties under the key <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262" title="Service property identifying all of the class names under which a service was registered in the frame...">ServiceConstants::OBJECTCLASS()</a>. </td></tr>
    <tr><td class="paramname">service</td><td>The service object or a <code><a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a></code> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. The keys in the properties object must all be <code>std::string</code> objects. See <a class="el" href="namespaceServiceConstants.html">ServiceConstants</a> for a list of standard service property keys. Changes should not be made to this object after calling this method. To update the service's properties the <a class="el" href="classServiceRegistration.html#a089f7b4f1af195b3e24b85f3795e04f5">ServiceRegistration::SetProperties</a> method must be called. The set of properties may be omitted if the service has no properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a></code> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If one of the following is true: <ul>
<li>
<code>service</code> is <code>0</code>. </li>
<li>
<code>properties</code> contains case variants of the same key name. </li>
</ul>
</td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5f83b5bac7475b7cce0a006696a5102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a> ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>clazz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">us::Base *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties under the specified class name with the framework. </p>
<p>This method is otherwise identical to RegisterService(const std:list&lt;std::string&gt;&amp;, us::Base*, const ServiceProperties&amp;) and is provided as a convenience when <code>service</code> will only be registered under a single class name. Note that even in this case the value of the service's <a class="el" href="namespaceServiceConstants.html#a0e099b4cc3cf6e80301486024950b262" title="Service property identifying all of the class names under which a service was registered in the frame...">ServiceConstants::OBJECTCLASS</a> property will be a std::list&lt;std::string&gt;, rather than just a single string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clazz</td><td>The class name under which the service can be located. </td></tr>
    <tr><td class="paramname">service</td><td>The service object or a <a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a7399fcc65ae1625cc06e4010e9e262d6" title="Registers the specified service object with the specified properties under the specified class names ...">RegisterService</a>(const std:list&lt;std::string&gt;&amp;, us::Base*, const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6" title="A hash table with std::string as the key type and Any as the value type.">ServiceProperties</a>&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a88ff1db40f40f1bf3c9435458de4b00b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServiceRegistration.html">ServiceRegistration</a> ModuleContext::RegisterService </td>
          <td>(</td>
          <td class="paramtype">us::Base *&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code><a class="el" href="group__MicroServices.html#ga7c543446fd5f54de926acacfd64e76d6">ServiceProperties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the specified service object with the specified properties using the specified template argument with the framework. </p>
<p>This method is provided as a convenience when <code>service</code> will only be registered under a single class name whose type is available to the caller. It is otherwise identical to RegisterService(const char*, US_BASECLASS_NAME*, const ServiceProperties&amp;) but should be preferred since it avoids errors in the string literal identifying the class name or interface identifier.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The type under which the service can be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service</td><td>The service object or a <a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a> object. </td></tr>
    <tr><td class="paramname">properties</td><td>The properties for this service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classServiceRegistration.html" title="A registered service.">ServiceRegistration</a> object for use by the module registering the service to update the service's properties or to unregister the service. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#ae5f83b5bac7475b7cce0a006696a5102" title="Registers the specified service object with the specified properties under the specified class name w...">RegisterService(const char*, us::Base*, const ServiceProperties&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76a2b8df55782e13155b456cb36054f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveModuleListener </td>
          <td>(</td>
          <td class="paramtype">const ModuleListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83e370982ef6be2003c7cad780229219"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveModuleListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classModuleEvent.html">ModuleEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified <code>callback</code> from the context module's list of listeners. </p>
<p>If the <code>(receiver,callback)</code> pair is not contained in this context module's list of listeners, this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be removed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object from which to disconnect. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#aabf1334ac62ee534b54f017e2a54df80">AddModuleListener()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae59a924bd2d3bf4d8c77abe4a0f61bd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveServiceListener </td>
          <td>(</td>
          <td class="paramtype">const ServiceListener &amp;&#160;</td>
          <td class="paramname"><em>delegate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ceb1d79f61232619c53f2e7f26812ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleContext::RemoveServiceListener </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(R::*)(const <a class="el" href="classServiceEvent.html">ServiceEvent</a>)&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the specified <code>callback</code> from the context module's list of listeners. </p>
<p>If the <code>(receiver,callback)</code> pair is not contained in this context module's list of listeners, this method does nothing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the receiver (containing the member function to be removed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>The object from which to disconnect. </td></tr>
    <tr><td class="paramname">callback</td><td>The member function pointer to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a649b0101ead2e7beef159191484b7913">AddServiceListener()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a070a6218b13e363098d546425c02f13c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ModuleContext::UngetService </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classServiceReference.html">ServiceReference</a> &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the service object referenced by the specified <code><a class="el" href="classServiceReference.html" title="A reference to a service.">ServiceReference</a></code> object. </p>
<p>If the context module's use count for the service is zero, this method returns <code>false</code>. Otherwise, the context modules's use count for the service is decremented by one.</p>
<p>The service's service object should no longer be used and all references to it should be destroyed when a module's use count for the service drops to zero.</p>
<p>The following steps are taken to unget the service object: </p>
<ol>
<li>
If the context module's use count for the service is zero or the service has been unregistered, <code>false</code> is returned. </li>
<li>
The context module's use count for this service is decremented by one. </li>
<li>
If the context module's use count for the service is currently zero and the service was registered with a <code><a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a></code> object, the <a class="el" href="classServiceFactory.html#afd632ca2040e8cfd403e787e9887a1bf" title="Releases a service object.">ServiceFactory::UngetService</a> method is called to release the service object for the context module. </li>
<li>
<code>true</code> is returned. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>A reference to the service to be released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the context module's use count for the service is zero or if the service has been unregistered; <code>true</code> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If this <a class="el" href="classModuleContext.html" title="A module&#39;s execution context within the framework.">ModuleContext</a> is no longer valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classModuleContext.html#a2bdfe2bcbae824b0cd6aa79bc4489850" title="Returns the service object referenced by the specified ServiceReference object.">GetService</a> </dd>
<dd>
<a class="el" href="classServiceFactory.html" title="Allows services to provide customized service objects in the module environment.">ServiceFactory</a> </dd></dl>

</div>
</div>
</div><!-- contents -->

  <hr class="footer"/>
  <address class="footer"><small>Generated on Fri Jul 19 2013 for C++ Micro Services 1.99.0 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.3.1
</small></address>
