--- a/miniz.c
+++ b/miniz.c
@@ -189,6 +189,10 @@
 // callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
 // functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.
 //#define MINIZ_NO_MALLOC
+
+#ifndef MINIZ_NO_STDIO
+  #include <stdio.h>
+#endif
 
 #if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
   // TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux
@@ -535,6 +539,7 @@
 typedef struct mz_zip_archive_tag
 {
   mz_uint64 m_archive_size;
+  mz_uint64 m_archive_file_ofs;
   mz_uint64 m_central_directory_file_ofs;
   mz_uint m_total_files;
   mz_zip_mode m_zip_mode;
@@ -628,6 +633,7 @@
 
 #ifndef MINIZ_NO_STDIO
 mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
+mz_bool mz_zip_writer_init_stream(mz_zip_archive *pZip, FILE* pFile, mz_uint64 size_to_reserve_at_beginning);
 #endif
 
 // Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive.
@@ -3210,11 +3216,17 @@
   if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
     return MZ_FALSE;
 
-  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
+  cdir_ofs = cur_file_ofs - cdir_size;
   if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
     return MZ_FALSE;
 
   pZip->m_central_directory_file_ofs = cdir_ofs;
+
+  pZip->m_archive_file_ofs = pZip->m_archive_size -
+                             (MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS) + cdir_size +
+                              MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_COMMENT_SIZE_OFS));
+  if (pZip->m_archive_file_ofs > pZip->m_archive_size)
+    return MZ_FALSE;
 
   if (pZip->m_total_files)
   {
@@ -3573,7 +3585,7 @@
     return MZ_FALSE;
 
   // Read and parse the local directory entry.
-  cur_file_ofs = file_stat.m_local_header_ofs;
+  cur_file_ofs = pZip->m_archive_file_ofs + file_stat.m_local_header_ofs;
   if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
     return MZ_FALSE;
   if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
@@ -4054,15 +4066,23 @@
 mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
 {
   MZ_FILE *pFile;
+  if (NULL == (pFile = MZ_FOPEN(pFilename, "wb")))
+  {
+    return MZ_FALSE;
+  }
+  return mz_zip_writer_init_stream(pZip, pFile, size_to_reserve_at_beginning);
+}
+
+mz_bool mz_zip_writer_init_stream(mz_zip_archive *pZip, FILE *pFile, mz_uint64 size_to_reserve_at_beginning)
+{
+  if (NULL == pFile)
+  {
+    return MZ_FALSE;
+  }
   pZip->m_pWrite = mz_zip_file_write_func;
   pZip->m_pIO_opaque = pZip;
   if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
     return MZ_FALSE;
-  if (NULL == (pFile = MZ_FOPEN(pFilename, "wb")))
-  {
-    mz_zip_writer_end(pZip);
-    return MZ_FALSE;
-  }
   pZip->m_pState->m_pFile = pFile;
   if (size_to_reserve_at_beginning)
   {
@@ -4610,7 +4630,7 @@
   if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
     return MZ_FALSE;
 
-  cur_src_file_ofs = MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
+  cur_src_file_ofs = pSource_zip->m_archive_file_ofs + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
   cur_dst_file_ofs = pZip->m_archive_size;
 
   if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)

